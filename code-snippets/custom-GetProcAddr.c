FARPROC GetInfoAddress(IN HMODULE hNTDLL, IN LPCSTR ProcName) {
	// Save The Base Address Of Module
	PBYTE pBase = (PBYTE)hNTDLL;

	// Find The Dos Header And Do a Check
	PIMAGE_DOS_HEADER pImgDos = (PIMAGE_DOS_HEADER)pBase;
	if (pImgDos->e_magic != IMAGE_DOS_SIGNATURE) {
		printf("Not a Valid Dos header");
		return NULL;
	}

	// Find The NT Header And Do a Check, e_lfanew points to it
	PIMAGE_NT_HEADERS pImgNT = (PIMAGE_NT_HEADERS)(pBase + pImgDos->e_lfanew);
	if (pImgNT->Signature != IMAGE_NT_SIGNATURE) {
		printf("Not a Valid NT Header");
		return NULL;
	}

	// Get The Option Header Address
	IMAGE_OPTIONAL_HEADER pImgOpt = pImgNT->OptionalHeader;

	
	PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + pImgOpt.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	// Save The Addresses Of Names, Functions And the Oridnals
	PDWORD FuncNameArray = (PDWORD)(pBase + pImgExportDir->AddressOfNames);
	PDWORD FuncAddrArray = (PDWORD)(pBase + pImgExportDir->AddressOfFunctions);
	PWORD FuncOrdinalArray = (PWORD)(pBase + pImgExportDir->AddressOfNameOrdinals);

	// Loop Through Each Function And Check if it == The Needed Function And If So
	for (DWORD i = 0; i < pImgExportDir->NumberOfFunctions; i++) {
		CHAR* pFuncName = (CHAR*)(pBase + FuncNameArray[i]);

		PVOID pFuncAddr = (PVOID)(pBase + FuncAddrArray[FuncOrdinalArray[i]]);

		if (strcmp(ProcName, pFuncName) == 0) {
			// Return The Address Of the Current Function
			return pFuncAddr;
		}
	}
	return NULL;
}
